<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>草草集</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shibinfei.github.io/"/>
  <updated>2018-06-25T08:46:24.587Z</updated>
  <id>https://shibinfei.github.io/</id>
  
  <author>
    <name>shibinfei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>社交场景下的数据模型设计</title>
    <link href="https://shibinfei.github.io/2018/06/25/%E7%A4%BE%E4%BA%A4%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1/"/>
    <id>https://shibinfei.github.io/2018/06/25/社交场景下的数据模型设计/</id>
    <published>2018-06-25T08:27:52.716Z</published>
    <updated>2018-06-25T08:46:24.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>分享一些在全宇宙最强交友大厂两年部分典型项目的设计经验和几个案例.</p><h2 id="数据模型设计建议"><a href="#数据模型设计建议" class="headerlink" title="数据模型设计建议"></a>数据模型设计建议</h2><h3 id="考虑使用没有业务含义的ID"><a href="#考虑使用没有业务含义的ID" class="headerlink" title="考虑使用没有业务含义的ID"></a>考虑使用没有业务含义的ID</h3><p>实际上这一点几乎是共识, 但是之前有0经验的同学问到, 突然发现也是很重要的一点. 以之前设计的用户表为例, 虽然最初业务仅支持手机号登录, 但使用手机号作为用户主键是完全不可行的, 原因即手机号有业务含义, 很容易发生变更 - 比如用户换了手机号, 或者手机有一天不再是主流通信方式(正如当年的邮箱一样).</p><p>所以通常会使用没有业务含义的ID, 比如自增. 然后为其他的通信方式单独建立一张表关联, 手机单独存放一个表, 微信登录的openID单独存放一张表, 这样可以完美地应对业务变化.</p><h3 id="冗余数据"><a href="#冗余数据" class="headerlink" title="冗余数据"></a>冗余数据</h3><p>这个概念实际上有点类似”反范式化”设计.  举个栗子, 在关系型数据库中有<code>t_user</code>, <code>t_biz</code>两个表, <code>t_biz</code>通过<code>f_uid</code>关联<code>t_user</code>的数据.  如果在<code>t_biz</code>的使用中需要使用到<code>t_user</code>的<code>f_sex</code>字段,  而且<code>f_sex</code>字段在业务上<strong>不允许变更</strong>. 在这里可以直接把<code>f_sex</code>字段直接保存在<code>t_biz</code>中, 避免数据关联.</p><p>但是冗余数据不止冗余一个字段这么简单, 还可以扩展到更广义的范围. 比如</p><ul><li>一条记录存两份</li><li>保存数据到其他存储引擎</li></ul><p>再举两个例子</p><h4 id="最新认证"><a href="#最新认证" class="headerlink" title="最新认证"></a>最新认证</h4><p>之前刚刚入职时负责了一个身份认证相关的模块, 其中一个feature叫”最新认证”. 但是认证数据本身有分表,  稚嫩的我采用了如下方案: 几个线程并发去查所有分表, 然后将结果保存到缓存, 从而避免频繁查询对系统造成压力.</p><p>实际上这是一个非常愚蠢的设计. 首先是代码比较复杂, 其次是无法完全实时. 而且一次去查所有分表, 性能完全没有保障. 所以当时改成了: 监听认证事件, 将新认证用户维护到一个redis的队列中, 这样直接取缓存就好了~</p><h4 id="互动关系"><a href="#互动关系" class="headerlink" title="互动关系"></a>互动关系</h4><p>社交类应用最常见的就是两个用户之间的互动关系, 比如关注, 送礼物. 这类业务的特点是会发生双向查询, 以关注为例, 会查询”我关注的”, 以及”关注我的”.</p><p>同样, 关注功能的最基本设计如下.  如下表示ID为1的用户关注了ID为2的用户.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+----------+-----------+---------------------+</span><br><span class="line">| id   | follower | following | createTime          |</span><br><span class="line">+------+----------+-----------+---------------------+</span><br><span class="line">|    1 |        1 |         2 | 2018-05-25 10:30:18 |</span><br><span class="line">+------+----------+-----------+---------------------+</span><br></pre></td></tr></table></figure><p>至于索引, 由于此类关系一般都需要双向查找, 即一个人会找自己关注的所有人, 以及一个人也会查看自己的所有粉丝, 所以<code>follower</code>,<code>following</code>一列都要单独建立索引.</p><p>而终于有一天, 这个表数据量大到单表有点把持不住了(线上关注关系接近1亿) . 需要对表进行水平拆分, 例如采用分表的方式, 分成1000张表. 通常会按照用户ID来分表, 如果用户ID是整型那就更方便了 - 可以直接按照尾数拆分.</p><p>不过这样问题就来了, 如果表结构不变, 以<code>follower</code>作为分表键, 那么查找一个用户关注的人没有问题, 但是一个用户找自己的粉丝却是不可行的, 因为<code>following</code>不是分表键, 这次查找需遍历所有的表.</p><p>解决方案就是: 一个关注关系写两份数据, 并添加一列来标识”当前用户”, 从而保证一个用户的关注/粉丝固定在同一个表中. 先看下表结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from Followship_001;</span><br><span class="line">+------+------+----------+-----------+---------------------+</span><br><span class="line">| id   | uid  | follower | following | createTime          |</span><br><span class="line">+------+------+----------+-----------+---------------------+</span><br><span class="line">|    1 |    1 |        1 |         2 | 2018-05-25 10:49:52 |</span><br><span class="line">+------+------+----------+-----------+---------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from Followship_002;</span><br><span class="line">+------+------+----------+-----------+---------------------+</span><br><span class="line">| id   | uid  | follower | following | createTime          |</span><br><span class="line">+------+------+----------+-----------+---------------------+</span><br><span class="line">|    1 |    2 |        1 |         2 | 2018-05-25 10:49:47 |</span><br><span class="line">+------+------+----------+-----------+---------------------+</span><br></pre></td></tr></table></figure><p>分表键为新增的<code>uid</code>字段, 并为其建立索引. 所以当我们找用户ID为1的关注列表, 只要<code>select * from Followship_001 where uid=1 and follower=uid</code>即可, 如果查找粉丝只需要把后面的条件换成<code>and following=uid</code>即可.</p><p>这个模式也是个典型的空间换时间案例, 实际上都是出于同样的理念: 事先存储好, 而不是实时地去计算.  </p><h3 id="用户数据和运营数据分离"><a href="#用户数据和运营数据分离" class="headerlink" title="用户数据和运营数据分离"></a>用户数据和运营数据分离</h3><p>这个问题源自内部的一个血泪教训. 之前照片的设计大致如下:  根据用户ID做分表,  并通过myisam的union机制实现跨越分表的查询. 而需要跨越分表的原因, 还需要看下字段设计:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UserPhoto_00 &#123;</span><br><span class="line">`uid` int(11),</span><br><span class="line">`auditStatus` smallint(6),</span><br><span class="line">`updateTime` datetime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致看起来, 如果只做用户业务使用是没有什么问题的, 按照uid进行分表, 可以迅速定位到用户数据. 问题出在这张表同时也被审核人员使用, 而审核人员通常是按照时间(<code>updateTime</code>)来筛选数据的. 而数据量是亿级, 所以在这一列建立了索引, 而且控制了范围(比如只能查一周内)的情况下, 速度依然非常慢. 而且直接加大数据库压力, 影响普通用户的业务.  </p><p>正常的姿势, 当然是审核表单独划分出来~~~</p><h2 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h2><h3 id="XX小组Feed设计"><a href="#XX小组Feed设计" class="headerlink" title="XX小组Feed设计"></a>XX小组Feed设计</h3><h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>2016年初参与了一个叫做”XX小组”的群组社交APP + 服务号开发. 实际上是借鉴了当时韩国非常火的”Band”. 国内实际上也有类似的App, 比如小密圈. 公司内部对于这个项目非常重视, 团队加班加点两个月开发完成后, 最终由于没钱投放胎死腹中. 当然了, 经验还是积累下来了.</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>首先群组生产的内容(比如一篇文章)保存在以群ID为Sharding Key + 索引的表中.</p><hr><p>这里反省一下, 团队当时用的数据库是MongoDB, 事后看来完全是为了用而用. MongoDB在我们的应用中几乎没有提供特别的便利, 而其中的数据库设计几乎可以完全套到MySQL中. 如<mongodb实战>所说:</mongodb实战></p><blockquote><p>一般来说， 数据生成越频繁， 就越不应该将这些数据内嵌到其他文档中。 如果内嵌 字段或者内嵌字段数量是无限增长的， 那么应该将这些内容保存在单独的集合中， 使用引用的方式进行访问， 而不是内嵌到其他文档中。 评论列表或者活动列表等信 息应该保存在单独的集合中，不应该内嵌到其他文档中。</p></blockquote><p>出于上面提到的原因, 我们的评论等等内容都是单独保存到其他集合. 真是勇敢的尝试~</p><hr><p>之前有看过其他公司的Feed方案, 都是基于Pull/Push的模型. 最近看&lt;设计数据密集型应用&gt;中第一章也有提到, 有兴趣可以了解一下. 不过具体业务和其他应用还是不大一样:</p><ul><li>与微博不同, 订阅内容来自”小组”而不是个人.</li><li>每个组的人数是有限制的, 最多只有1000.</li></ul><p>实际上出于性能考虑, 每次刷新Feed列表即时的去拉是完全不可取的; 而且注意, 由于小组人数限制, 并不存在微博的”大V扇出”(一个用户拥有千万级别粉丝时, 需要冗余非常多的数据)的问题, 所以选择推模型比较合理.</p><p>综上, 除了群数据之外, 还为每个用户维护了一个缓存, 基于Redis的zset, 其中保存的成员为内容ID, score为时间.</p><p>这个方案的优点是:</p><ul><li>占用空间比较小, 如果用户长时间不活跃缓存可以得到回收.</li><li>符合动态”时间序”的特性, 也方便根据时间查询.</li><li>方便控制数量.</li></ul><p>所以大体上注意在用户加入小组/离开小组, 小组发布新内容时更新对应用户的缓存即可. 另外通过队列对发布和扇出解除耦合.</p><h3 id="问答社区"><a href="#问答社区" class="headerlink" title="问答社区"></a>问答社区</h3><h4 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>这是当年做在主站App中的一个模块, 实际上不止一次尝试过做”问答”相关的特性, 这里讲参与的两次融合到一起.</p><p>这个功能有点类似”如故”: 系统提供指定数量的问题和选项. 用户可以 <em>选择选项(可能多选)</em>, 部分题目还额外有 <em>文字回答</em>, 文字回答 <em>审核后才可以被其他人查看</em>. 作答后也可以 <em>查看其他人的答案</em>, 进行 <em>点赞</em>, <em>评论</em>. 回答后还可以 <em>匹配三观相似</em> 的用户.</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>实际上如果经验丰富的话, 本案例价值可能不大. 重要的都是一些琐碎的细节.</p><p>首先是问题本身的两个表, 分别用于存储问题和提供的选项. 这没什么好说的~~ 实际上这里有点适合文档模型, 基于MySQL, 如果选项个数存在变化的可能性(呵, 不能信产品)则要两个表:</p><ul><li>Question : questionId, content, status(是否开启), aspect</li><li>Option : optionId, questionId, seqId(选项中的第几个), content, score(每个选项会有一个分数)</li></ul><p>之后即用户的答案了, 使用用户ID作为分表键.</p><ul><li>Answer : answerID, userID, questionID, options, wordAnswer, privateWordAnswer, auditStatus, praiseCount,  commentCount.</li></ul><p>这里的options, 表示用户选择的选项, 使用整型. 由于支持多选, 所以直接存seqId则需要保存多条记录, 比较麻烦. 于是选择使用bit, 举个栗子, 如果选择了A, 则把第0个bit置为1. 这样的话完美的支持了多选的情况. 而且几十个bit完全足够产品的需求了, 一个题目10个选项最多了~</p><p>praiseCount, commentCount表示赞数, 评论数. 这些值实际上可以从点赞表/评论表获取, 但是查看数量需要实时进行计算. 但是从性能角度来看是不可取的, 所以选择冗余出来.</p><p>同样, score也是Option表中本来就有的数据, 但由于此字段不会变化, 为了方便查询, 直接冗余到用户答案表中即可.</p><p>privateWordAnswer和auditStatus. 如果用户A填写了文字答案, 首先会写入privateWordAnswer, 并不会写入wordAnswer字段. 注意产品逻辑中, 文字答案未审核是不可以给别人查看的, 但是自己可以看得到.  </p><p>此时还没有审核, 如果用户B查看A回答过的问题, 那么直接查wordAnswer字段. 如果A查看自己的, 则展示privateWordAnswer字段. 如果审核通过, 则将privateWordAnswer赋值给wordAnswer, 则当前用户和其他用户视角相同. 这样做的优点是如果用户需要查看自己的回答, 避免查两个表以及麻烦的关联.</p><p>答案审核表 AnswerAudit: 本着用户数据和运营数据分离的原则, 新建一张审核表. 在用户提交回答后, 保存一份数据到审核表, 审核通过之后更新会用户答案表.</p><p>三观匹配:</p><p>由于公司业务特性, 一般的匹配都要加上地区属性. 产品的要求是, 匹配当前地级市的用户, 按照回答问题 + 答案相同个数来排序. 如果没有则放宽到市. 后期的匹配实际上逻辑已经非常复杂, 交给数据分析部门的推荐系统了, 但是前期逻辑简单, 直接使用ElasticSearch实现.</p><p>可以看出来, 地区是个<code>filter</code>条件, 不需要参与<code>score</code>的计算. 我们直接将用户回答的所有问题ID + 选项ID拼接起来, 保存为ES文档中的列表, 根据此列计算分数即可. 以一个用户的回答列表做入参, 查询出的<code>score</code>越大, 表示三观越相似.</p><p>数据的同步使用阿里开源项目<code>Canal</code> , 订阅答案表变动同步到ElasticSearch.</p><h3 id="附近的人"><a href="#附近的人" class="headerlink" title="附近的人"></a>附近的人</h3><h4 id="功能介绍-2"><a href="#功能介绍-2" class="headerlink" title="功能介绍"></a>功能介绍</h4><p>典型的LBS, 功能没有什么特别的. 参考微信”附近的人”</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>实际上这里要强调下选型的重要性: 使用MongoDB的2DSphere索引可以非常方便的实现这一功能.  </p><p>更重要的是, 服务端的位置依赖客户端上报, 但无法保证持续更新用户的位置. 举例如用户A上报了位置, 随后退出App, 那么数据库中对于的位置信息就不再变更了. 这样的话, 用户B看到附近有A, 而实际上A可能不在附近. 这里是Mongo的另一个方便之处: 支持TTL. 如果文档很久没有更新, 则自动过期, 即可解除业务上的缺陷.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;分享一些在全宇宙最强交友大厂两年部分典型项目的设计经验和几个案例.&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="Unknown" scheme="https://shibinfei.github.io/categories/Unknown/"/>
    
    
      <category term="Unknown" scheme="https://shibinfei.github.io/tags/Unknown/"/>
    
  </entry>
  
  <entry>
    <title>Kafka基本结构和关键指标</title>
    <link href="https://shibinfei.github.io/2018/05/19/Kafka%20-%20Overview/"/>
    <id>https://shibinfei.github.io/2018/05/19/Kafka - Overview/</id>
    <published>2018-05-19T07:34:36.117Z</published>
    <updated>2018-05-19T07:38:21.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>希望有基本Kafka使用经验的用户对Kafka有进一步认识. 大部分内容是来自2017年度好书之一《Kafka权威指南》的笔记~~</p><p>内容包括</p><ul><li>一些基本姿势</li><li>重要指标</li><li>对比RocketMQ</li></ul><h2 id="整体架构描述"><a href="#整体架构描述" class="headerlink" title="整体架构描述"></a>整体架构描述</h2><h3 id="Topic-amp-Broker-amp-Producer-amp-Consumer-ConsumerGroup"><a href="#Topic-amp-Broker-amp-Producer-amp-Consumer-ConsumerGroup" class="headerlink" title="Topic &amp; Broker &amp; Producer &amp; Consumer / ConsumerGroup"></a>Topic &amp; Broker &amp; Producer &amp; Consumer / ConsumerGroup</h3><p>这几个概念是最基本的, 不作太多描述.</p><ul><li>A topic is a category or feed name to which records are published.</li><li>对于一个指定的ConsumerGroup, 共享一整份数据. 即对于消费组中的每个消费者来说, 只能消费一部分数据.</li><li>Broker : 存储数据, 处理生成消费请求. 当启动了Kafka进程, 即为启动了一个Broker. 多个Broker构成了一个Kafka集群. (Zookeeper: /brokers/ids)</li></ul><h3 id="Partition-amp-Replica"><a href="#Partition-amp-Replica" class="headerlink" title="Partition &amp; Replica"></a>Partition &amp; Replica</h3><h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>从物理角度讲, 一个Topic的数据会被分为多个Partition, 保存在不同的Broker上.一条重要的规则是, 一个Partition同时最多只能被一个Consumer消费, 即Partition和Consumer之间是多对一/一对一的. 所以注意创建Topic时分区数量会影响消费的吞吐量. 不过分区数也可以改大.</p><h4 id="Replica"><a href="#Replica" class="headerlink" title="Replica"></a>Replica</h4><p>我们造, 数据保存在一个机器上可用性较低. 所以通常每个Partition会的数据会保存多份在不同的Broker中, 即多个副本. 这些副本中, 只有一个会用于处理Provider,Consumer的请求, 称之为Leader副本; 其他副本只是负责同步数据, 称之为Follower副本. 这样如果Leader跪了, 那么Follower可能被提升上来.</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>对于一个Topic, 指定分区数为3, 副本数为3. 共有共同属于一组的2个消费者, 整体情况如图.</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/Kafka.png?t=1" alt=""></p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>Leader是如何选出来的? 如果跪了谁负责重新选举? 整个集群中, 一个Broker会被选举为控制器(Zookeeper: /controller). 他额外负责的作用就是, 负责分区首领的选取.</p><h4 id="Controller自身的选举"><a href="#Controller自身的选举" class="headerlink" title="Controller自身的选举"></a>Controller自身的选举</h4><p>基于ZK节点<code>/controller</code>. 并额外通过<code>/controller_epoch</code>避免脑裂现象.</p><h4 id="Controller选择分区的首领副本"><a href="#Controller选择分区的首领副本" class="headerlink" title="Controller选择分区的首领副本"></a>Controller选择分区的首领副本</h4><p>控制器会观察Zookeeper中的Broker路径:</p><ul><li>如果有Leader Broker离开, 则会有一些分区需要一个新的Leader. Controller遍历这些分区, 选择新的Leader, 通知新的Leader/Follwer他们自己的身份.</li></ul><blockquote><p>当控制器发现一个 broker 加入集群时，它会使用 broker ID 来检查新加入的 broker 是否包 含现有分区的副本。如果有，控制器就把变更通知发送给新加入的 broker 和其他 broker， 新 broker 上的副本开始从首领那里复制消息。</p></blockquote><h3 id="再谈Producer-amp-Consumer"><a href="#再谈Producer-amp-Consumer" class="headerlink" title="再谈Producer &amp; Consumer"></a>再谈Producer &amp; Consumer</h3><h4 id="获取分区信息"><a href="#获取分区信息" class="headerlink" title="获取分区信息"></a>获取分区信息</h4><p>不论生产消费, 客户端都需要对现有的分区情况进行了解. 客户端定时(<code>metadata.max.age.ms</code>)向任意一个Broker(每一个都包含了需要的所有信息)发送感兴趣Topic的”元数据请求”, Broker会返回对应Topic的信息: 包含的分区、每个分区都有哪些副本, 以及哪个副本是首领。</p><blockquote><p>如果客户端收到“非首领”错误，它会在尝试重发请求之前先刷新元数据，因为这个错误说明了客户端正在使用过期的元数据信息，之前的请求被发到了错误的 broker 上。</p></blockquote><h4 id="写入哪个分区"><a href="#写入哪个分区" class="headerlink" title="写入哪个分区"></a>写入哪个分区</h4><p>键为<code>null</code>, 则默认根据Round Robin来发到各个分区. 如果指定了键, 那么有相同键的消息将被写到同一个分区。但是注意了:</p><blockquote><p>只有在不改变主题分区数量的情况下，键与分区之间的映射才能保持不变。举个例子，在分区数量保持不变的情况下，可以保证用户 045189 的记录总是被写到分区 34。在从分区读取数据时，可以进行各种优化。不过，一旦主题增加了新的分区，这些就无法保证了——旧数据仍然留在分区 34，但新的记录可能被写到其他分区上。</p></blockquote><p>另外也可以自己实现<code>Partitioner</code>.</p><h3 id="写入错误以及重试"><a href="#写入错误以及重试" class="headerlink" title="写入错误以及重试"></a>写入错误以及重试</h3><p>生成者可能收到<em>Broker返回</em>的错误分两种: 可以通过重试解决的错误 &amp; 无法通过重试解决的错误. 如果是可重试错误, Producer会根据配置(retries)来决定是否重试. 可以通过重试解决的的比如<code>LeaderNotAvailable</code>, 不可以的比如<code>InvalidConfig</code>, 消息大小错误, 认证错误.</p><p>Broker返回的错误中可以通过重试解决的, ProducerAPI会自动重试. 而不可以的需要开发者处理. 除了Broker返回的无法重试解决错误之外, 开发还需要处理:</p><ul><li>消息发送之前的错误: 序列化</li><li>Producer重试次数达到上限, 消息占用内存达到上限.</li></ul><h2 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h2><h3 id="数据保存多少"><a href="#数据保存多少" class="headerlink" title="数据保存多少"></a>数据保存多少</h3><blockquote><p>默认使用 log.retention.hours 参数来配置时间，默认值为 168 小时，也就是一周。</p><p>另一种方式是通过保留的消息字节数来判断消息是否过期。它的值通过参数 log.retention.bytes 来指定，作用在每一个分区上。也就是说，如果有一个包含 8 个分区的主题，并且 log.retention.bytes 被设为 1GB，那么这个主题最多可以保留 8GB 的数据。</p></blockquote><h3 id="KafkaConsumer-KafkaProducer线程安全性"><a href="#KafkaConsumer-KafkaProducer线程安全性" class="headerlink" title="KafkaConsumer, KafkaProducer线程安全性"></a><code>KafkaConsumer</code>, <code>KafkaProducer</code>线程安全性</h3><p><code>KafkaProducer</code>是线程安全的. 代码注释中有提到:</p><blockquote><p>The producer is <i>thread safe</i> and sharing a single producer instance across threads will generally be faster than having multiple instances.</p></blockquote><p>而<code>KafkaConsumer</code>则在<a href="https://kafka.apache.org/0100/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" target="_blank" rel="noopener">kafka 0.10.0.1 API</a>)中说明了它不是线程安全的. 其中的<code>wakeup()</code>方法是线程安全的, 目的是方便在A线程中终止B线程的消费. 容我直接Quote:</p><blockquote><p>The Kafka consumer is NOT thread-safe. All network I/O happens in the thread of the application making the call. It is the responsibility of the user to ensure that multi-threaded access is properly synchronized. Un-synchronized access will result in ConcurrentModificationException.<br>The only exception to this rule is wakeup(), which can safely be used from an external thread to interrupt an active operation. In this case, a WakeupException will be thrown from the thread blocking on the operation. This can be used to shutdown the consumer from another thread.</p></blockquote><p>如果想并发消费, 有下面两种方式</p><blockquote><ol><li>One Consumer Per Thread<br>A simple option is to give each thread its own consumer instance. Here are the pros and cons of this approach:<br>PRO: It is the easiest to implement<br>PRO: It is often the fastest as no inter-thread co-ordination is needed<br>PRO: It makes in-order processing on a per-partition basis very easy to implement (each thread just processes messages in the order it receives them).<br>CON: More consumers means more TCP connections to the cluster (one per thread). In general Kafka handles connections very efficiently so this is generally a small cost.<br>CON: Multiple consumers means more requests being sent to the server and slightly less batching of data which can cause some drop in I/O throughput.<br>CON: The number of total threads across all processes will be limited by the total number of partitions.</li><li>Decouple Consumption and Processing<br>Another alternative is to have one or more consumer threads that do all data consumption and hands off ConsumerRecords instances to a blocking queue consumed by a pool of processor threads that actually handle the record processing. This option likewise has pros and cons:<br>PRO: This option allows independently scaling the number of consumers and processors. This makes it possible to have a single consumer that feeds many processor threads, avoiding any limitation on partitions.<br>CON: Guaranteeing order across the processors requires particular care as the threads will execute independently an earlier chunk of data may actually be processed after a later chunk of data just due to the luck of thread execution timing. For processing that has no ordering requirements this is not a problem.<br>CON: Manually committing the position becomes harder as it requires that all threads co-ordinate to ensure that processing is complete for that partition.<br>There are many possible variations on this approach. For example each processor thread can have its own queue, and the consumer threads can hash into these queues using the TopicPartition to ensure in-order consumption and simplify commit.</li></ol></blockquote><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>实际上对于所有的MQ来说, 主要的评估指标都是下面这几个关键词</p><ul><li>可用性</li><li>重复</li><li>吞吐量</li><li>顺序性</li><li>丢失</li></ul><h3 id="基本保障"><a href="#基本保障" class="headerlink" title="基本保障"></a>基本保障</h3><blockquote><ol><li>Kafka 可以保证分区消息的顺序。如果使用同一个生产者往同一个分区写入消息，而且 消息 B 在消息 A 之后写入，那么 Kafka 可以保证消息 B 的偏移量比消息 A 的偏移量大， 而且消费者会先读取消息 A 再读取消息 B。</li><li>只有当消息被写入分区的所有同步副本时(但不一定要写入磁盘)，它才被认为是“已提交”的。生产者可以选择接收不同类型的确认，比如在消息被完全提交时的确认，或 者在消息被写入首领副本时的确认，或者在消息被发送到网络时的确认。</li><li>只要还有一个副本是活跃的，那么已经提交的消息就不会丢失。</li><li>消费者只能读取已经提交的消息。</li></ol></blockquote><p>所以如果需要注意顺序性, 则尽量将需要保证顺序的数据, 提供相同的Key. Kafka的配置都是各项指标之间的权衡, 是一种零和博弈.</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><h4 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式:"></a>发送方式:</h4><ul><li><code>Future&lt;RecordMetadata&gt;    send(ProducerRecord&lt;K,V&gt; record)</code></li><li><code>Future&lt;RecordMetadata&gt;    send(ProducerRecord&lt;K,V&gt; record, Callback callback)</code></li></ul><p>虽然异步发送本身也会重试, 但如果想确保发送成功后再处理后续操作, 则可以通过<code>future.get()</code>变成同步, 或者在<code>callback</code>中指定后续操作.</p><h4 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h4><p>吞吐量 还是 丢数据</p><ul><li>0: 如果能通过网络发送出消息就认为成功. (除非序列化错误, 或者网卡错误, 否则不会报错).</li><li>1: 只要Leader节点收到, 并写入分区数据文件(不一定是磁盘)即可. (首领崩溃, 暂未选举出来<code>LeaderNotAvailableException</code>会重试). 这种依然可能丢数据: 写入leader后, follower还没来得及同步, leader就挂了.</li><li>all: 首领在返回确认或错误响应之前，会等待所有同步副本都收到消息。如 果和 min.insync.replicas 参数结合起来，就可以决定在返回确认前至少有多少个副本 能够收到消息。</li></ul><h4 id="retries-retry-backoff-ms"><a href="#retries-retry-backoff-ms" class="headerlink" title="retries, retry.backoff.ms"></a>retries, retry.backoff.ms</h4><p>丢数据 还是 重复</p><p>如果不设置重复, 那么可能会丢数据. 而如果设置了重试, 则有重复的风险: 假如由于网络问题没有收到Broker确认, 实际上却成功了, 那么重试的话就多了一条.</p><p>所以说, 如果使用了多次重试, 可以保证”at least once”, 不能保证”exactly once”.</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><h4 id="default-replication-factor-replication-factor"><a href="#default-replication-factor-replication-factor" class="headerlink" title="default.replication.factor, replication.factor"></a>default.replication.factor, replication.factor</h4><p>硬件成本 还是 可靠性</p><p>设置多个副本可用性更高, 但硬件成本也更高. 一般设置3个就足够安全.   </p><h4 id="replica-lag-time-max-ms"><a href="#replica-lag-time-max-ms" class="headerlink" title="replica.lag.time.max.ms"></a>replica.lag.time.max.ms</h4><p>来自<a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener">Apache Kafka - Documentation</a>)</p><blockquote><p>If a follower hasn’t sent any fetch requests or hasn’t consumed up to the leaders log end offset for at least this time, the leader will remove the follower from isr</p></blockquote><p>ISR是in-sync replica的缩写.</p><h4 id="unclean-leader-election"><a href="#unclean-leader-election" class="headerlink" title="unclean.leader.election"></a>unclean.leader.election</h4><p>一致性(可能丢数据) 还是 可用性</p><blockquote><p>当分区首领不可用时，一个同步副本会被选为新首领。如果在选举过程中没有丢失数据，也就是说提交的数据同时存在于所有的同步副本上，那么这个选举就是 “完全选举”.<br>如果把 unclean.leader.election.enable 设为 true，就是允许不同步的副本成为首领, 即允许“不完全的选举”</p></blockquote><p>两个极端Case, 假设副本数量为3</p><ul><li>两个follower跪了. 后来leader也跪了, 然后一个follower启动. 那么这个follower是唯一可用的, 但是是不同步的.</li><li>两个follower因为网络原因不同步. Leader突然跪了, 数据永远无法同步~</li></ul><p>选择: 在数据无法一致的情况下, 是否提升一个Follower做leader?</p><ul><li>否: 只能等之前的leader恢复, 否则系统一直不可用</li><li>是: 数据不一致.</li></ul><blockquote><p>大部分银行系统宁愿选择在几分钟甚至几个小时内不处理信用卡支 付事务，也不会冒险处理错误的消息。</p></blockquote><h4 id="min-insync-replicas"><a href="#min-insync-replicas" class="headerlink" title="min.insync.replicas"></a>min.insync.replicas</h4><p>可用性 还是 一致性</p><p>表示至少有多少个同步的副本, 才允许向对应分区写数据. 比如当此项设置为2, 如果3个副本中有两个不同步了. 那么写时会抛出<code>NotEnoughReplicas</code>.</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>消费者侧的主要问题就是发生在<code>Rebalance</code>阶段: 当一个Consumer退出, 需要将本属于他的分区交给另一个Consumer.</p><p>如果所有的Consumer都能稳定地存活那是最理想的了, 可是如果其中一个消费者挂掉, 另一个接替他分区的从哪里开始处理? 答案就是, 消费者会向Broker提交自己消费的offset, 表示消费完了哪些数据. <strong>消费者端大部分问题都源于offset的提交</strong></p><h4 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto.offset.reset"></a>auto.offset.reset</h4><p>当消费者最开始加入的时候, 是根据配置决定从哪里读的: 最近(<code>latest</code>), 或者最早<code>earliest</code>.  设置为最近则可能会丢数据, 设置为最早, 则可能重复消费数据.</p><h4 id="enable-auto-commit-auto-commit-interval-ms"><a href="#enable-auto-commit-auto-commit-interval-ms" class="headerlink" title="enable.auto.commit/auto.commit.interval.ms."></a>enable.auto.commit/auto.commit.interval.ms.</h4><p>重复 还是 性能<br>是否自动提交/自动提交间隔. 如果使用自动提交, 频率比较低, 那么重复数据可能性更大, 如果太频繁就会有额外开销.</p><p>如果手动提交, 同样要注意提交频率. 也要注意是<code>commitSync</code>还是<code>commitAsync</code>:</p><blockquote><p>在成功提交或碰到无法恢复的错误之前，commitSync() 会一直重试，但是 commitAsync() 不会，这也是 commitAsync() 不好的一个地方。它之所以不进行重试，是因为在它收到 服务器响应的时候，可能有一个更大的偏移量已经提交成功。假设我们发出一个请求用 于提交偏移量 2000，这个时候发生了短暂的通信问题，服务器收不到请求，自然也不会 作出任何响应。与此同时，我们处理了另外一批消息，并成功提交了偏移量 3000。如果 commitAsync() 重新尝试提交偏移量 2000，它有可能在偏移量 3000 之后提交成功。这个时 候如果发生再均衡，就会出现重复消息。<br>我们之所以提到这个问题的复杂性和提交顺序的重要性，是因为 commitAsync() 也支持回 调，在 broker 作出响应时会执行回调。回调经常被用于记录提交错误或生成度量指标，不 过如果你要用它来进行重试，一定要注意提交的顺序。</p></blockquote><h4 id="恰当处理Rebalance"><a href="#恰当处理Rebalance" class="headerlink" title="恰当处理Rebalance"></a>恰当处理Rebalance</h4><p> <code>ConsumerRebalanceListener</code> 有两个需要实现的方法.<code>onPartitionsRevoked(Collection&lt;TopicPartition&gt; partitions)</code>方法会在 再均衡开始之前和消费者停止读取消息之后被调用。如果在这里提交偏移量，下一个接管分区的消费者就知道该从哪里开始读取了。</p><h4 id="幂等消费"><a href="#幂等消费" class="headerlink" title="幂等消费"></a>幂等消费</h4><p>如上文所说, 如果因重试导致Kafka无法保证<code>exactly once</code> , 则消费时要保证操作是幂等的.</p><h4 id="处理消费中遇到的错误"><a href="#处理消费中遇到的错误" class="headerlink" title="处理消费中遇到的错误"></a>处理消费中遇到的错误</h4><p>假如消费到, 但是部分调用出现故障(比如数据库), 可以放进另一个队列里, 等会消费. @see RocketMQ (%RETRY%,  %DLQ%)</p><h2 id="RocketMQ对比"><a href="#RocketMQ对比" class="headerlink" title="RocketMQ对比"></a>RocketMQ对比</h2><p>这篇<a href="http://rocketmq.apache.org/docs/motivation/" target="_blank" rel="noopener">Motivation - Apache RocketMQ</a>中说明的比较全面.</p><ul><li>Kafka支持单个Partition内的顺序保证, RocketMQ能保证全局的顺序性. (?好奇如何保证的)</li><li>消息回溯, Kafka支持基于offset, RocketMQ支持基于offset和时间.</li><li>RocketMQ支持调度消息(延迟)</li><li>RocketMQ支持Broadcast</li><li>Kafka需要依赖Zookeeper.</li><li>RocketMQ支持RETRY,  DLQ</li></ul><p>但是根据阿里的文档来看, 上面这些并不是当初实现RocketMQ的主要目的. 主要的原因是RocketMQ在更多Queue(对应 Kafka Partition), 更多Topic的场景下性能更好. 从而提升了队列的生产消费并行度. 性能更好的原因 <a href="http://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/" target="_blank" rel="noopener">How to Support More Queues in RocketMQ? - Apache RocketMQ</a>和<a href="http://jm.taobao.org/2016/03/24/rmq-vs-kafka/" target="_blank" rel="noopener">RocketMQ与kafka对比（18项差异） | 阿里中间件团队博客</a>都有提到.</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://www.beyondthelines.net/computing/kafka-patterns/" target="_blank" rel="noopener">Kafka Patterns</a></li><li><a href="https://kafka.apache.org/documentation/" target="_blank" rel="noopener">Apache Kafka</a></li><li>《Kafka权威指南 - Neha Narkhede, Gwen Shapira, Todd Palino》</li><li><a href="https://stackoverflow.com/questions/45686885/how-does-kafka-store-offsets-for-each-topic" target="_blank" rel="noopener"> How does Kafka store offsets for each topic? - Stack Overflow</a></li><li><a href="https://kafka.apache.org/10/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html" target="_blank" rel="noopener">Kafka 1.0.1 API</a></li><li><a href="https://www.confluent.io/blog/exactly-once-semantics-are-possible-heres-how-apache-kafka-does-it/" target="_blank" rel="noopener">Exactly-once Semantics is Possible: Here’s How Apache Kafka Does it</a></li><li><a href="http://jm.taobao.org/2016/04/07/kafka-vs-rocketmq-topic-amout/" target="_blank" rel="noopener">Kafka vs RocketMQ—— Topic数量对单机性能的影响 | 阿里中间件团队博客</a></li><li><a href="http://jm.taobao.org/2016/03/24/rmq-vs-kafka/" target="_blank" rel="noopener">RocketMQ与kafka对比（18项差异） | 阿里中间件团队博客</a></li><li><a href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/" target="_blank" rel="noopener">十分钟入门RocketMQ | 阿里中间件团队博客</a></li><li><a href="http://rocketmq.apache.org/docs/motivation/" target="_blank" rel="noopener">RocketMQ Documentation - Motivation</a></li><li><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践 - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Foreword&quot;&gt;&lt;a href=&quot;#Foreword&quot; class=&quot;headerlink&quot; title=&quot;Foreword&quot;&gt;&lt;/a&gt;Foreword&lt;/h2&gt;&lt;p&gt;希望有基本Kafka使用经验的用户对Kafka有进一步认识. 大部分内容是来自2017年度好
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="MessageQueue" scheme="https://shibinfei.github.io/tags/MessageQueue/"/>
    
  </entry>
  
  <entry>
    <title>JVM Tools</title>
    <link href="https://shibinfei.github.io/2018/05/13/JVM%20-%20Tools/"/>
    <id>https://shibinfei.github.io/2018/05/13/JVM - Tools/</id>
    <published>2018-05-13T08:39:00.155Z</published>
    <updated>2018-05-14T03:28:17.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>排查线上问题必备~ 本章内容基于JDK8.  相关内容在<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html" target="_blank" rel="noopener">Java Platform, Standard Edition Tools Reference for Oracle JDK on Solaris, Linux, and OS X, Release 8</a>写的很详细.</p><ul><li>JDK基本工具类位于<code>$JAVA_HOME/bin</code>.</li><li>这些工具类的实现基于<code>tools.jar</code>, 它不是Java标准API, HotSpot提供的.  所以能开箱即用的只有HotSpot虚拟机.  </li><li>部分JDK小工具参考了UNIX命名方式, 如 <code>jps</code>和<code>ps</code>功能类似.  </li><li>如果对命令的选项不清楚, 直接执行 <code>命令名 -help</code>即可查询.</li></ul><h2 id="1-jps"><a href="#1-jps" class="headerlink" title="1. jps"></a>1. jps</h2><p>列出正在运行的虚拟机进程. <code>jps [options] [hostid]</code></p><ul><li>-m : 输出传递给main函数的参数</li><li>-l : 输出主类的全名/jar包路径</li><li>-v : 输出JVM参数</li></ul><h2 id="2-jstat"><a href="#2-jstat" class="headerlink" title="2. jstat"></a>2. jstat</h2><p>这个命令功能比较多, 根据选项可以对一个JVM进程某个特定指标进行查询. 这里展示的结果项非常多,</p><p>比如查看GC情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jstac -gc 5234 // 查看进程好5234的GC情况</span><br><span class="line"></span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">61440.0 61440.0 10961.4  0.0   491520.0 10220.7   204800.0   32791.2   62688.0 61132.7 7412.0 7099.1     10    1.826   4      0.261    2.087</span><br></pre></td></tr></table></figure><p>观察结果, 截止到<code>CCSU</code>之前都可用下面两条组合解释:</p><ul><li><code>S0</code>, <code>S1</code>表示新生代中的两个Survivor区域. E表示Eden. O表示Old Gen. M表示MetaSpace. CCS表示压缩类空间(Compressed Class Space), 它是MetaSpace的一部分.</li><li>C即Capacity, 表示容量. U为USED, 表示已用多少. 单位都是KB.</li></ul><p><code>CCSU</code>后面的含义如下;</p><ul><li>YGC : 年轻代GC次数</li><li>YGCT : 年轻代GC时间</li><li>FGC : 年老代GC次数</li><li>FGCT : 年老带GC时间</li><li>GCT : GC消耗总时间</li></ul><p><code>jstat</code>的基本格式为:  <code>jstat [option vmid [interval[s|ms]] [count]]</code>.</p><p>刚刚的<code>option</code>是<code>-gc</code>. <code>interval</code>和<code>count</code>分别表示: 每隔<code>interval</code>执行一次, 共执行<code>count</code>次后结束. <code>jstat -gc 5234 2s 3</code>, 即没两秒执行一次, 执行3次后结束. 除了<code>-gc</code>之外还支持:</p><h3 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat -class 5234</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line"> 10751 20031.0        0     0.0      15.25</span><br></pre></td></tr></table></figure><p>依次表示 加载的类数量,  字节数,  卸载的类数量, 卸载的类字节数. 加载类耗费的时间.</p><h3 id="complier"><a href="#complier" class="headerlink" title="-complier"></a>-complier</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -compiler 5234</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    9198      2       0    79.12          1 sun/misc/URLClassPath getNextLoader</span><br></pre></td></tr></table></figure><h3 id="printcompilation"><a href="#printcompilation" class="headerlink" title="-printcompilation"></a>-printcompilation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -printcompilation 5234</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">    9198     57    1 com/netflix/servo/monitor/Monitors isNumericType</span><br></pre></td></tr></table></figure><h3 id="其他GC相关"><a href="#其他GC相关" class="headerlink" title="其他GC相关"></a>其他GC相关</h3><h4 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccapacity 5234</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC</span><br><span class="line">614400.0 614400.0 614400.0 61440.0 61440.0 491520.0   204800.0   204800.0   204800.0   204800.0      0.0 1103872.0  62688.0      0.0 1048576.0   7412.0     10     4</span><br></pre></td></tr></table></figure><p>观察后缀, 主要多了<code>MN</code>, <code>MX</code>, 同样指的是<code>Capacity</code>,分别表示最小, 最大.</p><h4 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil 5234</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 17.84   0.00   9.50  16.01  97.52  95.78     10    1.826     4    0.261    2.087</span><br></pre></td></tr></table></figure><p>以百分比格式输出占用量.</p><h4 id="gcnew-gcold-gcnewcapacity-gcoldcapacity"><a href="#gcnew-gcold-gcnewcapacity-gcoldcapacity" class="headerlink" title="-gcnew, -gcold, -gcnewcapacity, -gcoldcapacity"></a>-gcnew, -gcold, -gcnewcapacity, -gcoldcapacity</h4><p>功能应该可以猜到了.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcold 5234</span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT</span><br><span class="line"> 62688.0  61132.7   7412.0   7099.1    204800.0     32791.2     10     4    0.261    2.087</span><br><span class="line"></span><br><span class="line">jstat -gcnew 5234</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">61440.0 61440.0 10961.4    0.0  6   6 30720.0 491520.0  46711.6     10    1.826</span><br></pre></td></tr></table></figure></p><p>这里有点奇怪的是, 为什么MetaSpace归属到Old Gen的统计中了? 另外年轻代有三个之前没有看过的指标: <code>TT</code>, <code>MTT</code>, <code>DSS</code></p><blockquote><p>TT: Tenuring threshold.<br>MTT: Maximum tenuring threshold.<br>DSS: Desired survivor size (kB).</p></blockquote><h4 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gccause 5234</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC</span><br><span class="line"> 17.84   0.00  16.91  16.01  97.52  95.78     10    1.826     4    0.261    2.087 Allocation Failure   No GC</span><br></pre></td></tr></table></figure><p>同样以百分比输出, 多了个<code>LGCC</code>, 即 Last GC Cause.  <code>GCC</code>, 表示当前GC原因.</p><h2 id="3-jinfo"><a href="#3-jinfo" class="headerlink" title="3. jinfo"></a>3. jinfo</h2><p>查看参数信息和System Properties.  其中有很多重要信息, 包括一些默认的JVM参数. 除次之外很多框架都将属性<code>System.setProperties</code>, 可以直接通过此命令查看.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">jinfo 5234</span><br><span class="line"></span><br><span class="line">Attaching to process ID 5234, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.121-b13</span><br><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">java.runtime.name = Java(TM) SE Runtime Environment</span><br><span class="line">sun.rmi.transport.tcp.responseTimeout = 8000</span><br><span class="line">java.vm.version = 25.121-b13</span><br><span class="line">sun.boot.library.path = /usr/local/jdk1.8.0_121/jre/lib/amd64</span><br><span class="line">java.vendor.url = http://java.oracle.com/</span><br><span class="line">java.vm.vendor = Oracle Corporation</span><br><span class="line">path.separator = :</span><br><span class="line">file.encoding.pkg = sun.io</span><br><span class="line">java.vm.name = Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">sun.os.patch.level = unknown</span><br><span class="line">sun.java.launcher = SUN_STANDARD</span><br><span class="line">user.country = US</span><br><span class="line">user.dir = /data/dubbo/test-project/jiangnenghua</span><br><span class="line">java.vm.specification.name = Java Virtual Machine Specification</span><br><span class="line">PID = 5234</span><br><span class="line">java.runtime.version = 1.8.0_121-b13</span><br><span class="line">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment</span><br><span class="line">os.arch = amd64</span><br><span class="line">java.endorsed.dirs = /usr/local/jdk1.8.0_121/jre/lib/endorsed</span><br><span class="line">org.jboss.logging.provider = slf4j</span><br><span class="line">line.separator =</span><br><span class="line"></span><br><span class="line">java.io.tmpdir = /tmp</span><br><span class="line">java.vm.specification.vendor = Oracle Corporation</span><br><span class="line">os.name = Linux</span><br><span class="line">sun.jnu.encoding = UTF-8</span><br><span class="line">java.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class="line">spring.beaninfo.ignore = true</span><br><span class="line">sun.nio.ch.bugLevel =</span><br><span class="line">java.specification.name = Java Platform API Specification</span><br><span class="line">java.class.version = 52.0</span><br><span class="line">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class="line">os.version = 3.10.0-693.2.2.el7.x86_64</span><br><span class="line">user.home = /home/publish</span><br><span class="line">user.timezone = Asia/Shanghai</span><br><span class="line">java.awt.printerjob = sun.print.PSPrinterJob</span><br><span class="line">file.encoding = UTF-8</span><br><span class="line">@appId = test-project</span><br><span class="line">java.specification.version = 1.8</span><br><span class="line">header.errorCode = true</span><br><span class="line">user.name = publish</span><br><span class="line">java.class.path = test-project.jar</span><br><span class="line">java.vm.specification.version = 1.8</span><br><span class="line">sun.arch.data.model = 64</span><br><span class="line">sun.java.command = test-project.jar</span><br><span class="line">java.home = /usr/local/jdk1.8.0_121/jre</span><br><span class="line">user.language = en</span><br><span class="line">java.specification.vendor = Oracle Corporation</span><br><span class="line">awt.toolkit = sun.awt.X11.XToolkit</span><br><span class="line">java.vm.info = mixed mode</span><br><span class="line">java.version = 1.8.0_121</span><br><span class="line">java.ext.dirs = /usr/local/jdk1.8.0_121/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class="line">sun.boot.class.path = /usr/local/jdk1.8.0_121/jre/lib/resources.jar:/usr/local/jdk1.8.0_121/jre/lib/rt.jar:/usr/local/jdk1.8.0_121/jre/lib/sunrsasign.jar:/usr/local/jdk1.8.0_121/jre/lib/jsse.jar:/usr/local/jdk1.8.0_121/jre/lib/jce.jar:/usr/local/jdk1.8.0_121/jre/lib/charsets.jar:/usr/local/jdk1.8.0_121/jre/lib/jfr.jar:/usr/local/jdk1.8.0_121/jre/classes</span><br><span class="line">java.awt.headless = true</span><br><span class="line">java.vendor = Oracle Corporation</span><br><span class="line">file.separator = /</span><br><span class="line">java.vendor.url.bug = http://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding = UnicodeLittle</span><br><span class="line">sun.cpu.endian = little</span><br><span class="line">sun.cpu.isalist =</span><br><span class="line"></span><br><span class="line">VM Flags:</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=3 -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:+DisableExplicitGC -XX:InitialHeapSize=838860800 -XX:LargePageSizeInBytes=134217728 -XX:MaxHeapSize=838860800 -XX:MaxNewSize=629145600 -XX:MaxTenuringThreshold=6 -XX:MinHeapDeltaBytes=196608 -XX:NewSize=629145600 -XX:OldPLABSize=16 -XX:OldSize=209715200 -XX:+PrintGC -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ThreadStackSize=512 -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseFastAccessorMethods -XX:+UseFastUnorderedTimeStamps -XX:+UseParNewGC</span><br><span class="line">Command line:  -Xmx800m -Xms800m -Xmn600m -Xss512k -XX:PermSize=128m -XX:MaxPermSize=512m -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -verbose:gc -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/data/dubbo/test-project/log/jvm.log -Dfile.encoding=UTF-8 -Dheader.errorCode=true</span><br></pre></td></tr></table></figure><p>选项 :</p><blockquote><p>-flag name : Prints the name and value of the specified command-line flag.<br>-flag [+|-]name : enables or disables the specified Boolean command-line flag.<br>-flag name=value : Sets the specified command-line flag to the specified value.<br>-flags : Prints command-line flags passed to the JVM.<br>-sysprops : Prints Java system properties as name-value pairs.</p></blockquote><h2 id="4-jmap"><a href="#4-jmap" class="headerlink" title="4. jmap"></a>4. jmap</h2><p>功能为dump出堆内存情况. 先看如何使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=test.dump 5234</span><br></pre></td></tr></table></figure><p>把PID为5234的虚拟机进程堆内存情况dump到test.dump这个文件中.<br>如果指定live选项<code>jmap -dump:live,for...</code> 则表示只dumo对中活跃的对象. 注意结果文件不是人类可读的, 需要通过工具如<code>jhat</code>或者VisualVM这种工具来.  一般不使用<code>jhat</code>, 就不介绍了. 通过VisualVM 1.4.1, File -&gt; Load, 选择文件即可.</p><p><code>dump</code>是最常用的, 除此之外还支持:</p><ul><li>没有任何选项. // TODO</li><li>finalizerInfo: 打印F-Queue中等待Finalizer线程执行finalize方法的对象.</li><li>F : 当使用<code>-dump</code>, <code>-histo</code>选项时, 如果虚拟机没有反应, 可以加此选项强制. 但不能和live子选项共同使用.</li></ul><h3 id="Heap"><a href="#Heap" class="headerlink" title="-Heap"></a>-Heap</h3><p>显示堆的摘要信息.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 5234</span><br><span class="line">Attaching to process ID 5234, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.121-b13</span><br><span class="line"></span><br><span class="line">using parallel threads in the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 838860800 (800.0MB)</span><br><span class="line">   NewSize                  = 629145600 (600.0MB)</span><br><span class="line">   MaxNewSize               = 629145600 (600.0MB)</span><br><span class="line">   OldSize                  = 209715200 (200.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 566231040 (540.0MB)</span><br><span class="line">   used     = 143663072 (137.00778198242188MB)</span><br><span class="line">   free     = 422567968 (402.9922180175781MB)</span><br><span class="line">   25.371811478226274% used</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 503316480 (480.0MB)</span><br><span class="line">   used     = 132438616 (126.30330657958984MB)</span><br><span class="line">   free     = 370877864 (353.69669342041016MB)</span><br><span class="line">   26.313188870747883% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 62914560 (60.0MB)</span><br><span class="line">   used     = 11224456 (10.704475402832031MB)</span><br><span class="line">   free     = 51690104 (49.29552459716797MB)</span><br><span class="line">   17.840792338053387% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 62914560 (60.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 62914560 (60.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation:</span><br><span class="line">   capacity = 209715200 (200.0MB)</span><br><span class="line">   used     = 33578192 (32.02265930175781MB)</span><br><span class="line">   free     = 176137008 (167.9773406982422MB)</span><br><span class="line">   16.011329650878906% used</span><br><span class="line"></span><br><span class="line">27645 interned Strings occupying 3042984 bytes.</span><br></pre></td></tr></table></figure><p>可以看到其中包含一些GC信息, 以及Interned String的数量和存储容量.</p><h3 id="histo-histo-live"><a href="#histo-histo-live" class="headerlink" title="-histo (-histo:live)"></a>-histo (-histo:live)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 5234 &gt;&gt; test.histo</span><br><span class="line">head test.histo</span><br><span class="line"></span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          5110        9967304  [I</span><br><span class="line">   2:         88631        9287640  [C</span><br><span class="line">   3:         87076        2089824  java.lang.String</span><br><span class="line">   4:         23722        2087536  java.lang.reflect.Method</span><br><span class="line">   5:          7440        1724888  [B</span><br><span class="line">   6:         45469        1455008  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">   7:         11349        1271616  java.lang.Class</span><br></pre></td></tr></table></figure><p>显示堆中每个类的实例数量, 和所占容量大小. 也支持live选项, 含义和<code>-dump</code>中一样, 也表示仅仅统计活跃的对象.</p><h3 id="clstats"><a href="#clstats" class="headerlink" title="-clstats"></a>-clstats</h3><p>打印堆中的ClassLoader统计. 包括名称, 活跃度, 地址, 父级ClassLoader, 加载的Class数量等信息.</p><h2 id="5-jstack"><a href="#5-jstack" class="headerlink" title="5. jstack"></a>5. jstack</h2><p>线程信息, 支持选项</p><ul><li>-F : 当VM hang住时使用此选项.</li><li>-l : 显示锁信息</li><li>-m : 如果有调用Native方法, 显示其(C/C++)栈信息()</li></ul><h2 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h2><p>VisualVM的功能实际上是上述几个命令的集合. 一个问题是VisualVM通常不会安装在服务端, 所以需要Server开启JMX端口, 才可以被监控. 需要添加的JVM参数如下:</p><ul><li>-Dcom.sun.management.jmxremote.port=9876 // 为VM实例指定JMX端口</li><li>-Dcom.sun.management.jmxremote.ssl=false // 禁用ssl</li><li>-Dcom.sun.management.jmxremote.authenticate=false // 禁用授权校验 (用户名密码)</li><li>-Djava.rmi.server.hostname=10.1.5.54 // 本机IP</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Foreword&quot;&gt;&lt;a href=&quot;#Foreword&quot; class=&quot;headerlink&quot; title=&quot;Foreword&quot;&gt;&lt;/a&gt;Foreword&lt;/h2&gt;&lt;p&gt;排查线上问题必备~ 本章内容基于JDK8.  相关内容在&lt;a href=&quot;https://d
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Java Tools" scheme="https://shibinfei.github.io/tags/Java-Tools/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Feature - 03. 连接模型</title>
    <link href="https://shibinfei.github.io/2018/04/26/Dubbo%20Feature%2003%20-%20%E8%BF%9E%E6%8E%A5%E6%A8%A1%E5%9E%8B/"/>
    <id>https://shibinfei.github.io/2018/04/26/Dubbo Feature 03 - 连接模型/</id>
    <published>2018-04-26T13:30:24.336Z</published>
    <updated>2018-04-26T13:30:58.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>请先了解</p><ul><li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/config-connections.html" target="_blank" rel="noopener">6.29 连接控制 · GitBook</a></li><li><a href="http://dubbo.apache.org/books/dubbo-user-book/demos/lazy-connect.html" target="_blank" rel="noopener">6.30 延迟连接 · GitBook</a></li><li><a href="http://dubbo.apache.org/books/dubbo-user-book/references/xml/dubbo-protocol.html" target="_blank" rel="noopener">8.3 Scheme配置参考手册 - dubbo:protocol · GitBook</a></li></ul><p>本章内容针对<code>DubboProtocol</code>.</p><h2 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h2><p>默认情况下, 一个Consumer和一个指定的Provider之间只会建立一个连接(无论两者之间有多少个服务调用).  </p><p>在Linux平台中, 可以通过<code>netstat</code>命令查看两者之间的连接. 下方栗子为在同一机器上运行Provider, Consumer的结果:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp6       0      0 :::48707                :::*                    LISTEN      32753/java-&gt; Provider</span><br><span class="line">tcp6       0      0 10.1.5.54:48806         10.1.5.54:48707         ESTABLISHED 363/java-&gt; Consumer</span><br><span class="line">tcp6       0      0 10.1.5.54:55894         10.1.5.76:48707         ESTABLISHED 363/java</span><br><span class="line">tcp6       0      0 10.1.5.54:48707         10.1.5.54:48806         ESTABLISHED 32753/java</span><br></pre></td></tr></table></figure><p>服务端的端口是配置中指定的, 而Consumer端开启的端口是一个随机的临时端口. 如果有同一机器上有多个Dubbo Consumer和Provider实例的情况下, 偶尔会遇到端口被占用的情况, 即为临时端口的缘故.</p><h3 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h3><p>连接的建立和前文的<code>ProtocolFilterWrapper.buildInvokerChain</code>在同一链路上.  起于<code>DubboProtocol.refer</code>中, 其中调用了<code>getClients()</code>, 获取到了<code>ExchangeClient[]</code>, 用来实例化<code>DubboInvoker</code> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;</span><br><span class="line">     // create rpc invoker.</span><br><span class="line">     DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">     invokers.add(invoker);</span><br><span class="line">     return invoker;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>getClients</code>方法注释中有说明:</p><blockquote><p>If not configured, connection is shared, otherwise, one connection for one service</p></blockquote><p>当然了, 即一个Provider的一个服务建立一个连接. <code>DubboProtocol</code>中通过<code>referenceClientMap</code>来持有共享的<code>ReferenceCountExchangeClient</code>实例, key为<code>URL</code>如<code>10.1.1.1:20880</code>.  默认情况下一个URL只会调用<code>getSharedClient</code>获取一个共享的实例, 如果用户有配置<code>connections</code>, 则会调用多次<code>initClient</code>, 建立多个连接.</p><p><em>更多: ReferenceCountExchangeClient, ghostClientMap</em></p><h3 id="延迟连接"><a href="#延迟连接" class="headerlink" title="延迟连接"></a>延迟连接</h3><p>继续观察<code>initClient</code>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) &#123;</span><br><span class="line">client = new LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">client = Exchangers.connect(url, requestHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果配置了<code>lazy = true</code>, 则实际上并没有直接建立连接, 而是返回<code>LazyConnectExchangeClient</code>. 它也是<code>ExchangeClient</code> 的实现类. 实现延迟的方式实际上只是覆盖<code>request</code>,<code>send</code>方法, 在其中调用<code>initClient</code>, 判断<code>client</code>为空才建立连接. 建立连接也是调用上文代码<code>else</code>分支的这一句: <code>client = Exchangers.connect(url, requestHandler);</code></p><h3 id="从Exchangers到具体连接建立"><a href="#从Exchangers到具体连接建立" class="headerlink" title="从Exchangers到具体连接建立"></a>从<code>Exchangers</code>到具体连接建立</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exchangers.connect(URL, ExchangeHandler)</span><br><span class="line">-&gt; HeaderExchanger.connect(URL, ExchangeHandler)</span><br><span class="line">-&gt; Transpoters.connect(URL, ChannelHandler)</span><br><span class="line">-&gt; NettyTransporter.connect(ChannelHandler)</span><br><span class="line">-&gt; NettyClient.connect()</span><br></pre></td></tr></table></figure><h3 id="服务端连接控制"><a href="#服务端连接控制" class="headerlink" title="服务端连接控制"></a>服务端连接控制</h3><p>上面说明的都是IO的客户端内容, 服务端的连接控制<code>acceptes</code>是在客户端与其连接建立之后发生的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NettyHandler.channelConnnected</span><br><span class="line">-&gt; NettyServer(AbstraceServer).connected</span><br></pre></td></tr></table></figure><p>其中直接判断, 如果连接数量大于指定数量, 即将连接关闭:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (accepts &gt; 0 &amp;&amp; channels.size() &gt; accepts) &#123;</span><br><span class="line">    logger.error(&quot;Close channel &quot; + ch + &quot;, cause: The server &quot; + ch.getLocalAddress() + &quot; connections greater than max config &quot; + accepts);</span><br><span class="line">    ch.close();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>Dubbo中有实现应用层的心跳机制.  在Consumer(<code>HeaderExchangeClient</code>)端和Provider(<code>HeaderExchangeServer</code>)端都会开启一个<code>HeartBeatTask</code>.</p><p>Consumer端如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DubboProtocol.refer</span><br><span class="line">DubboProtocol.initClient</span><br><span class="line">Exchangers.connect</span><br><span class="line">HeaderExchanger.connect</span><br><span class="line">HeaderExchangeClient.startHeartbeatTimer</span><br></pre></td></tr></table></figure><p>而在Provider端<code>export</code>和Consumer端<code>refer</code>之后也都会实例化一个<code>HeartbeatHandler</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DubboProtocol.export</span><br><span class="line">-&gt; ChannelHandlers.wrap</span><br><span class="line">-&gt; HeartbeatHandler&lt;init&gt;</span><br></pre></td></tr></table></figure><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><ul><li>观察<code>HeartbeatHandler</code>,  除了<code>received</code>方法之外的其他方法, 基本只是额外加了对于最后<strong>读写</strong>时间的记录.</li><li>两端都会开启<code>HeartbeatTask</code>, 默认每隔一分钟(<code>heartbeat</code>)执行一次. 运行时, 对所有活跃的渠道遍历<ul><li>如果最后读取写时间距今超过一分钟(<code>heartbeat</code>), 则向<code>Channel</code>中发送一个<code>event</code>为<code>Request.HEARTBEAT_EVENT</code>的<code>Request</code>.</li><li>如果最后读取时间距今超过三分钟((<code>heartbeat timeout</code>), 则如果当前实例为Consumer, 则尝试重新连接, 如果为Provider端, 则关闭连接.     </li></ul></li><li>继续看<code>HeartbeatHandler.recieved</code><ul><li>如果收到心跳请求, 则回复一个心跳响应.</li><li>如果收到心跳响应, 则直接忽略.</li></ul></li></ul><p>值得注意的是, 由于Consumer和Provider端都开启了心跳调度线程, 所以在空闲时哪端先发起心跳是不确定的.</p><h3 id="心跳的作用"><a href="#心跳的作用" class="headerlink" title="心跳的作用"></a>心跳的作用</h3><p>文档中有对<code>heartbeat</code>属性做简要说明:</p><blockquote><p>心跳间隔，对于长连接，当物理层断开时，比如拔网线，TCP的FIN消息来不及发送，对方收不到断开事件，此时需要心跳来帮助检查连接是否已断开</p></blockquote><p>其中已经说明了FIN消息的不可靠性, 不仅拔网线, 系统层次的崩溃也会导致FIN消息无法发送. 如果有尝试写过Netty的<code>channelInactive</code>方法Demo, 可能会发现, 突然断网是无法触发的.</p><p>那么协议层的<code>keepAlive</code>呢?  翻过的资料相比应用层的心跳缺点如下:</p><ul><li>心跳的作用不止是了解两端是否连接活跃, 更重要的是判断对方功能是否正常.</li><li>TCP协议的keepalive不能穿过代理服务器(TCP keepalive would only check the connection up to the proxy and not the end-to-end connection).</li></ul><p>综合上面两点看来, 心跳的用处是判断<strong>对方是否能够提供正常功能</strong>. 而实际落实到Dubbo的语境下, 似乎不止于此.</p><p>// TODO 没有ZK的情况下, 实际上拔线或者kill程序, API端并没有立即反应, 等到调用时才报错.</p><h2 id="Netty-Configuration"><a href="#Netty-Configuration" class="headerlink" title="Netty Configuration"></a>Netty Configuration</h2><p>针对老版本Netty, 并非Netty4, 但实现类似.</p><p><code>NettyServer</code>和<code>NettyClient</code>的<code>bossExecutor</code>和<code>workerExecutor</code>都是<code>Executors.newCachedThreadPool</code>.</p><p>然而对于Netty线程模型并不熟悉, 不能对这一点发表更多意见. - -||</p><h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><p>此外<code>NettyClient</code>还有一些额外配置 :</p><pre><code>-  `keepAlive`: 上面已经提到过- `connectTimeoutMillis`- `tcpNoDelay`: 防止消息没有及时发送. 详见下方参考资料.</code></pre><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%B4%E6%97%B6%E7%AB%AF%E5%8F%A3" target="_blank" rel="noopener">临时端口 - 维基百科，自由的百科全书</a></li><li><a href="http://www.ncftp.com/ncftpd/doc/misc/ephemeral_ports.html" target="_blank" rel="noopener">The Ephemeral Port Range</a></li><li><a href="https://en.wikipedia.org/wiki/Watchdog_timer" target="_blank" rel="noopener">Watchdog timer - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Heartbeat_(computing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heartbeat_(computing</a>)</li><li><linux多线程服务端编程> - 陈硕 | 电子工业出版社</linux多线程服务端编程></li><li><a href="https://blog.csdn.net/historyasamirror/article/details/6423235" target="_blank" rel="noopener">网络编程之nagle算法和TCP_NODELAY - CSDN博客</a></li><li><a href="https://stackoverflow.com/questions/23238319/websockets-ping-pong-why-not-tcp-keepalive" target="_blank" rel="noopener">WebSockets ping/pong, why not TCP keepalive? - Stack Overflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Foreword&quot;&gt;&lt;a href=&quot;#Foreword&quot; class=&quot;headerlink&quot; title=&quot;Foreword&quot;&gt;&lt;/a&gt;Foreword&lt;/h2&gt;&lt;p&gt;请先了解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://dubbo.apache
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Dubbo" scheme="https://shibinfei.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Feature - 02. 并发控制</title>
    <link href="https://shibinfei.github.io/2018/04/21/Dubbo%20Feature%2002%20-%20%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>https://shibinfei.github.io/2018/04/21/Dubbo Feature 02 - 并发控制/</id>
    <published>2018-04-21T11:03:53.729Z</published>
    <updated>2018-04-21T11:04:46.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>了解本部分请先参考: <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/concurrency-control.html" target="_blank" rel="noopener">6.28 并发控制 · GitBook</a></p><p>相关代码位于 <em>dubbo-rpc-api</em></p><p>根据每个示例, 找到Dubbo对应实现代码的过程很简单. 由于Dubbo中几乎所有的配置都有一个Key, 所以直接在<code>Constants</code>(dubbo-common)中找到对应的Key调用即可. 比如配置<code>executes</code>对应的就是<code>Constants.EXECUTES_KEY</code>. 查找调用关系可以直接定位到<code>ExecuteLimitFilter</code>.</p><h2 id="Filter加载过程"><a href="#Filter加载过程" class="headerlink" title="Filter加载过程"></a>Filter加载过程</h2><h3 id="ExecuteLimitFilter"><a href="#ExecuteLimitFilter" class="headerlink" title="ExecuteLimitFilter"></a>ExecuteLimitFilter</h3><p> 首先来看下Provider端<code>ExecuteLimitFilter</code>的加载过程. 在dubbo-rpc-api中, <code>src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter</code>有配置<code>executelimit=com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</code>.  </p><p>Fillter的加载源于<code>ProtocolFilterWrapper.buildInvokerChain</code>, 在这里断点可以看到调用是从<code>ServiceBean</code>开始的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServiceBean.export</span><br><span class="line">-&gt; Protocol$Adaptive.export</span><br><span class="line">-&gt; ProtocolFilterWrapper.export</span><br><span class="line">-&gt; ProtocolFilterWrapper.buildInvokerChain</span><br></pre></td></tr></table></figure><p>其中获取所有Filter的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br></pre></td></tr></table></figure><p>根据之前对于Dubbo SPI的了解, <code>getActivateExtension</code>这一方法中, 扩展类需要满足<code>ExtensionLoader.isMatchGroup, 以及isActive</code>时才会返回, 所以在Provider端中, 且配置了<code>executes</code>属性时, 标记了<code>@Activate(group = Constants.PROVIDER, value = Constants.EXECUTES_KEY)</code>的<code>ExecuteLimitFilter</code>会被放到整个Filter Chain中.</p><p><code>buildInvokerChain</code>中传入的<code>invoker</code>是<code>JDKProxyFactory$1 (AbstractProxyInvoker)</code>. 在此方法中, 返回了一个Invoker, 观察<code>invoke(invocation)</code>方法的实现, 实际上是将invoker的invoke方法之外包裹了多层Filter, 而其中Filter中也会调用下一个Filter, 由此构成了一个责任链模式.</p><p>回想业务方法的栈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ChannelEventRunnable.run</span><br><span class="line">-&gt; DecodeHandler.received</span><br><span class="line">-&gt; HeaderExchangeHandler.recieved</span><br><span class="line">-&gt; HeaderExchangeHandler.handleRequest</span><br><span class="line">-&gt; DubboProtocol$1.reply // 匿名类ExchangeHandler</span><br><span class="line">-&gt; ProtocolFilterWrapper$1.invoke// 匿名类Invoker, Filter介入</span><br><span class="line">-&gt; EchoFilter.invoke</span><br><span class="line">... 每个Filter和ProtocolFilterWrapper$1的反复</span><br><span class="line">-&gt; RegisterProtocol$InvokerDelegete.invoke</span><br><span class="line">-&gt; DelegateProviderMetaDataInvoker.invoke</span><br><span class="line">-&gt; JavassistProxyFactory$1.invoke</span><br><span class="line">-&gt; Wrapper1.invokeMethod</span><br><span class="line">-&gt; DemoService.sayHello</span><br></pre></td></tr></table></figure></p><p>注: <code>$1</code>表示代码中的匿名类.</p><h3 id="ActiveLimitFilter"><a href="#ActiveLimitFilter" class="headerlink" title="ActiveLimitFilter"></a>ActiveLimitFilter</h3><p>Consumer端的<code>ActiveLimitFilter</code>加载过程类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicatonContext.getBean</span><br><span class="line">-&gt; ReferenceBean.crateProxy</span><br><span class="line">-&gt; Protocol$Adaptive.refer</span><br><span class="line">-&gt; QosProtocolWrapper.refer</span><br><span class="line">-&gt; ProtocolListenerWrapper.refer</span><br><span class="line">-&gt; ProtocolFilterWrapper.refer</span><br><span class="line">-&gt; RegistryProtocol.refer</span><br><span class="line">-&gt; RegistryDirectory.subscribe</span><br><span class="line">-&gt; ZookeeperRegistry.subscribe</span><br><span class="line">-&gt; ZookeeperRegistry.notify</span><br><span class="line">-&gt; RegistryDirectory.toInvokers</span><br><span class="line">-&gt; QosProtocolWrapper.refer</span><br><span class="line">另起一行</span><br><span class="line">-&gt; ProtocolListenerWrapper.refer</span><br><span class="line">-&gt; ProtocolFilterWrapper.refer</span><br><span class="line">-&gt; ProtocolFilterWrapper.buildInvokerChain</span><br></pre></td></tr></table></figure><p><code>buildInvokerChain</code>的参数是一个<code>DubboInvoker</code>.</p><p>涉及这一系列Filter的调用栈如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$Proxy11.sayHello</span><br><span class="line">-&gt; InvokerInvocationHandler.invoke</span><br><span class="line">-&gt; MockClusterInvoker.invoke</span><br><span class="line">-&gt; FailoverClusterInvoker.invoke</span><br><span class="line">-&gt; RegisterDirectory$InvokerDelegate.invoke</span><br><span class="line">-&gt; ListenerInvokerWrapper.invoker</span><br><span class="line">-&gt; ProtocolFilterWrapper$1.invoke</span><br><span class="line">-&gt; ConsumerContextFilter.invoke</span><br><span class="line">... ProtocolFilterWrapper$1.invoke与filter交替</span><br><span class="line">-&gt; DubboInvoker.invoke// DubboInvoker</span><br><span class="line"></span><br><span class="line">另起一行, 开始数据交互</span><br><span class="line">-&gt; RefercnceCountExchangeClient.request</span><br><span class="line">-&gt; HeaderExchangeClient.request</span><br><span class="line">-&gt; HeaderExchangeChannel.request</span><br><span class="line">-&gt; NettyClient.send</span><br></pre></td></tr></table></figure></p><h2 id="并发控制实现"><a href="#并发控制实现" class="headerlink" title="并发控制实现"></a>并发控制实现</h2><h3 id="ExecuteLimitHandler"><a href="#ExecuteLimitHandler" class="headerlink" title="ExecuteLimitHandler"></a>ExecuteLimitHandler</h3><p><code>ExecuteLimitHandler</code>的实现非常简单. 注意, 并发控制是方法级别的: Dubbo为每个方法对应了一个<code>RpcStatus</code>, 通过其中的<code>Semaphore</code>对象来控制线程数量, 没有<code>tryAcquire成功会抛出异常</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">throw new RpcException(&quot;Failed to invoke method &quot; + invocation.getMethodName() + &quot; in provider &quot; + url</span><br><span class="line">+ &quot;, cause: The service using threads greater than &lt;dubbo:service executes=\&quot;&quot; + max</span><br><span class="line">+ &quot;\&quot; /&gt; limited.&quot;);</span><br></pre></td></tr></table></figure><p>值得注意的是, 每个方法会有一个对应的<code>RPCStatus</code>. 所以<code>executes</code>直接配置给某个类时, 指的是其中每个方法的并发限制, 而不是所有方法并发的总和.</p><p>这个基于<code>Semaphore</code>的实现非常简单, 为了实现更彻底的控制和隔离, 有人接入了Hystrix, 也是通过Dubbo Filter进行扩展的. 请参考下方链接.</p><h3 id="ActiveLimitFilter-1"><a href="#ActiveLimitFilter-1" class="headerlink" title="ActiveLimitFilter"></a>ActiveLimitFilter</h3><p><code>ActiveLimitFilter</code>直接通过<code>RPCStatus</code>的计数功能来进行并发控制, 如果达到指定<code>active</code>数量, 会一直阻塞直到超时, 再抛出异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">throw new RpcException(&quot;Waiting concurrent invoke timeout in client-side for service:  &quot;</span><br><span class="line">                                    + invoker.getInterface().getName() + &quot;, method: &quot;</span><br><span class="line">                                    + invocation.getMethodName() + &quot;, elapsed: &quot; + elapsed</span><br><span class="line">                                    + &quot;, timeout: &quot; + timeout + &quot;. concurrent invokes: &quot; + active</span><br><span class="line">                                    + &quot;. max concurrent invoke limit: &quot; + max);</span><br></pre></td></tr></table></figure><p>这里的阻塞是直接通过<code>RPCStatus</code>继承自<code>Object</code>的<code>wait</code>,<code>notify</code>实现的.</p><p>另外值得注意的一点是虽然文档中表示:</p><blockquote><p>限制 com.foo.BarService 的每个方法，每客户端并发执行（或占用连接的请求数）不能超过 10 个：</p></blockquote><p>但实际上是, 客户端对<strong>每个Provider</strong>该方法的调用不能超过10个. 由于<code>METHOD_STATISTICS</code>中的Key是<code>URL</code>串, 比如 <code>dubbo://10.1.1.1:20880/com.alibaba.dubbo.demo.DemoService</code>. 所以对于不同Provider的相同方法, 实际上获取到的是两个不同的<code>RPCStatus</code>实例. 故可得到以上结论.</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="http://m635674608.iteye.com/blog/2312328" target="_blank" rel="noopener">使用Hystrix对Dubbo消费者提供线程隔离保护  - zzm - ITeye博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;了解本部分请先参考: &lt;a href=&quot;http://dubbo.apache.org/bo
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Dubbo" scheme="https://shibinfei.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Feature - 01. 线程模型</title>
    <link href="https://shibinfei.github.io/2018/04/18/Dubbo%20Feature%2001%20-%20%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>https://shibinfei.github.io/2018/04/18/Dubbo Feature 01 - 线程模型/</id>
    <published>2018-04-18T03:18:57.443Z</published>
    <updated>2018-04-18T03:22:05.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>了解本部分请先参考: <a href="http://dubbo.apache.org/books/dubbo-user-book/demos/thread-model.html" target="_blank" rel="noopener">Dubbo User Book - 6.4 线程模型 · GitBook</a></p><p>相关代码位于 <em>dubbo-remoting-api</em></p><h3 id="Call-stack"><a href="#Call-stack" class="headerlink" title="Call stack"></a>Call stack</h3><p>如果你曾经在Provider端的服务实现类中打过断点, 会发现调用是从<code>ChannelEventRunnable.run()</code>开始的, 这是因为默认情况下, Provider端的业务调用都是在一个单独的线程池中执行的, 即<code>WrappedChannelHandler</code>中的<code>executor</code>.</p><p>从IO线程中获取的数据分发到业务线程池, 这一功能在Dubbo被抽象成了<code>Dispatcher</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandler dispatch(ChannelHandler handler, URL url);</span><br></pre></td></tr></table></figure><p>根据此类上的<code>@SPI(AllDispatcher.NAME)</code>也可知默认为<code>AllDispatcher</code>. 实际的逻辑封装在<code>AllDispatcher</code>中返回的<code>AllChannelHandler</code>. 在其中的<code>received</code>方法中打断点, 调用栈如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NettyServer.received(Channel, Object)</span><br><span class="line">-&gt; MultiMessageHandler.received(Channel, Object)</span><br><span class="line">-&gt; HeartbeatHandler.received(Channel, Object)</span><br><span class="line">-&gt; AllChannelHandler.received(Channel, Object)</span><br></pre></td></tr></table></figure><p>由此Provider端调用栈即可形成一个闭环: 从Netty -&gt; 具体的业务实现.</p><h2 id="线程模型-Dispatcher"><a href="#线程模型-Dispatcher" class="headerlink" title="线程模型 - Dispatcher"></a>线程模型 - Dispatcher</h2><p>除了<code>DirectDispatcher</code>之外, 每一种配置都对应了一种<code>ChannelHandler</code>的实现类. 他们都是<code>WrappedChannelHandler</code>的子类.  </p><p><code>ChannelHandler</code>在Dubbo中很重要, 还有很多相关的子类暂时不需要关注. 我们先来看一下: <code>DirectDispatcher</code>和<code>AllDispatcher</code></p><ul><li><code>DirectDispatcher</code>最简单, 它直接返回了传入的<code>ChannelHandler</code>, 这个类即为<code>DecodeHandler</code>. 联系上面的调用栈可知下一步调用即为<code>DecodeHandler#received</code></li><li><code>AllDispatcher</code>覆盖了<code>WrappedChannelHandler</code>的几乎所有方法, 都是实例化一个<code>ChannelEventRunnable</code>, 交给<code>executor</code>执行. 在<code>ChannelEventRunnable</code>的<code>run</code>方法中再执行<code>DecodeHandler</code>的后续操作.</li></ul><p>如果了解过Dubbo的其他代码, 可以发现这又是常见的<strong>装饰模式</strong>.  四个类对后续的<code>ChannelHandler</code>(实际上是<code>DecodeHandler</code>)进行装饰, 实现内容实际上比较简单.</p><p>这里有个值得注意的问题是, execution 这一策略, 并没有实现. 具体实现跟文档描述并不一致. 可以参考<a href="https://github.com/apache/incubator-dubbo/issues/1089" target="_blank" rel="noopener">dispatcher:execution · Issue #1089 · apache/incubator-dubbo · GitHub</a> 以及 <a href="https://github.com/apache/incubator-dubbo/pull/1449" target="_blank" rel="noopener">fixes #1089, make ExecutionDispatcher meet dubbo-user-book by qct · Pull Request #1449 · apache/incubator-dubbo · GitHub</a></p><h2 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h2><p>线程池的实例化在<code>WrappedChannelHandler</code>中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url);</span><br></pre></td></tr></table></figure><p>默认情况下使用<code>FixedThreadPool</code>,  位于dubbo-commons</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FixedThreadPool implements ThreadPool &#123;</span><br><span class="line"></span><br><span class="line">    public Executor getExecutor(URL url) &#123;</span><br><span class="line">        String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        int threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);</span><br><span class="line">        int queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line">        return new ThreadPoolExecutor(threads, threads, 0, TimeUnit.MILLISECONDS,</span><br><span class="line">                queues == 0 ? new SynchronousQueue&lt;Runnable&gt;() :</span><br><span class="line">                        (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;()</span><br><span class="line">                                : new LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br><span class="line">                new NamedThreadFactory(name, true), new AbortPolicyWithReport(name, url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见默认情况下, 创建一个大小为200的线程池; 使用队列<code>SynchronousQueue</code>, 即可看作没有使用队列缓存元素. 并在饱和时抛出异常, 同时<code>jstack</code>日志到文件(<code>AbortPolicyWithReport</code>) .</p><h4 id="你或许需要使用MessageOnlyDispatcher"><a href="#你或许需要使用MessageOnlyDispatcher" class="headerlink" title="你或许需要使用MessageOnlyDispatcher:"></a>你或许需要使用<code>MessageOnlyDispatcher</code>:</h4><p>如果Dubbo线程池占满时, 很可能发现调用端获得的是超时异常.</p><p>注意上文提到的<code>WrappedChannelHandler</code>中有一个<code>caught</code>方法, 当发生异常时(暂时不需要了解此处的调用关系)会被执行.  参考下方<a href="http://manzhizhen.iteye.com/blog/2391177" target="_blank" rel="noopener">See Also第一篇</a>, 使用<code>AllChannelHandler</code>策略时, <code>caught</code>方法由于线程池满也被拒绝, 导致无法返回, 调用端只能等到Timeout.</p><p>另外一个问题是, <code>AllDispatcher</code>中如果判断<code>executor</code>为空或者已经<code>shutdown</code>, 会去拿<code>SHARED_EXECUTOR</code>. 这种场景并没有想到何时回出现, 希望知道的朋友指点.</p><h2 id="Call-Stack-上游"><a href="#Call-Stack-上游" class="headerlink" title="Call Stack 上游"></a>Call Stack 上游</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected ChannelHandler wrapInternal(ChannelHandler handler, URL url) &#123;</span><br><span class="line">    return new MultiMessageHandler(new HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.class)</span><br><span class="line">            .getAdaptiveExtension().dispatch(handler, url)));// 此处断点. handler就是上文提到的DecodeHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略了部分调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServiceBean.doExport()</span><br><span class="line">-&gt; DubboProtocol.export()</span><br><span class="line">-&gt; DubboProtocol.createServer</span><br><span class="line">-&gt; HeaderExchangers.bind</span><br><span class="line">-&gt; NettyTransporter.bind</span><br><span class="line">-&gt; NettyServer.&lt;init&gt;</span><br><span class="line">-&gt; ChannelHandlers.wrap</span><br><span class="line">-&gt; ChannelHandlers.wrapInternal</span><br></pre></td></tr></table></figure><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="http://manzhizhen.iteye.com/blog/2391177" target="_blank" rel="noopener">再说Provider线程池被EXHAUSTED - 大步流星 - ITeye博客</a></li><li><a href="https://github.com/kamranahmedse/design-patterns-for-humans#-decorator" target="_blank" rel="noopener">Design Patterns for Humans™ - Decorator</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;了解本部分请先参考: &lt;a href=&quot;http://dubbo.apache.org/bo
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Dubbo" scheme="https://shibinfei.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Outline of JVM Concepts - 01. 内存模型</title>
    <link href="https://shibinfei.github.io/2018/03/04/Outline%20of%20JVM%20Concepts%20-%2001.%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://shibinfei.github.io/2018/03/04/Outline of JVM Concepts - 01. 内存模型/</id>
    <published>2018-03-04T05:03:41.465Z</published>
    <updated>2018-03-04T05:04:41.466Z</updated>
    
    <content type="html"><![CDATA[<ul><li>&lt;深入理解Java虚拟机&gt; 第二版, 第二章摘录 + 笔记.</li></ul><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>总体概念示意:</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/JVM%20Memory%20Model.png" alt=""></p><h3 id="PC-计数器"><a href="#PC-计数器" class="headerlink" title="PC - 计数器"></a>PC - 计数器</h3><blockquote><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native 方法，这个计数器值则为空（Undefined）。</p></blockquote><h4 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h4><blockquote><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p></blockquote><h3 id="JVM虚拟机栈"><a href="#JVM虚拟机栈" class="headerlink" title="JVM虚拟机栈"></a>JVM虚拟机栈</h3><blockquote><p>每个方法在执行的同时都会创建一个栈帧（Stack Frame ）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></blockquote><p>栈帧概念后面详细说明. 通过<code>-Xss</code>设置栈的最大长度.</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>如果有人简单将JVM内存划分为堆栈, 那么栈即指的是局部变量表.  <code>long</code>,<code>double</code>占2个Slot, 其余占一个. (先别管什么是Slot).</p><ul><li>returnAddress  指向一条字节码指令的地址</li><li>reference 可能是指向对象起始地址的引用指针, 也可能指向对象句柄或者其他与对象相关的位置.</li></ul><h4 id="异常说明-1"><a href="#异常说明-1" class="headerlink" title="异常说明"></a>异常说明</h4><blockquote><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p></blockquote><p>限制栈容量, 通过无线递归即可实现. 在作者的实验中:</p><blockquote><p>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和JVM虚拟机栈类似. 区别为本地方法栈为虚拟机使用到的Native方法服务. 异常和虚拟机栈相同.</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><blockquote><p>此区域的唯一目的就是存放对象实例.</p><p>虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配 [1] ，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换 [2] 优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p></blockquote><p>从GC角度, 和内存分配角度可以进行更细致分类, 但是与实际存储内容无关.</p><p>调整Heap大小参数: <code>-Xmx, -Xms</code></p><h4 id="异常说明-2"><a href="#异常说明-2" class="headerlink" title="异常说明"></a>异常说明</h4><blockquote><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常.</p></blockquote><p>通过创建大数组和大量对象实现溢出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">* @author zzm</span><br><span class="line">*/</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    static class OOMObject &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main（String[]args）&#123;</span><br><span class="line">        List＜OOMObject＞list=new ArrayList＜OOMObject＞()；</span><br><span class="line">        while（true）&#123;</span><br><span class="line">        list.add（new OOMObject()）；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据. Java虚拟机规范把方法区描述为<strong>堆的一个逻辑部分</strong>，但是它却有一个别名叫Non-Heap，目的应该是与Java堆区分开.</p></blockquote><p>有人将方法区称为PermGen, 是因为从HotSpot GC角度来讲, 使用PermGen来实现方法区, 而其他虚拟机没有这个概念. 而实际上JDK8中已经去掉了PermGen. 在后面的GC部分说明.</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><blockquote><p>Runtime Constant Pool是方法区的一部分.</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table), 用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p></blockquote><p>但是运行时常量池中的数据不一定来自编译好的Class文件, 也可能在运行时中加入, 比如<code>String.intern</code>.</p><blockquote><p>对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。</p></blockquote><p>从HotSpot的GC角度来讲, 在JDK7之前, 常量池放在PermGen中, 而7中则已经移除了PermGen. (GC部分详细说明).</p><h4 id="异常说明-3"><a href="#异常说明-3" class="headerlink" title="异常说明"></a>异常说明</h4><p>可能抛出<code>OutOfMemoryError</code>. 首先限制PermGen大小: <code>-XX:PermSize=10M -XX:MaxPermSize=10M</code>. 然后:</p><ul><li>在JDK6以及之前, 可以通过限制PermGen并无限对字符串进行<code>intern</code>来实现溢出.</li><li>也可以通过CGLib等工具无限生成类来实现.</li></ul><h4 id="关于常量池的有趣栗子"><a href="#关于常量池的有趣栗子" class="headerlink" title="关于常量池的有趣栗子"></a>关于常量池的有趣栗子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = new StringBuilder(&quot;计算机&quot;).append(&quot;软件&quot;).toString()；</span><br><span class="line">System.out.println(str1.intern() == str1)；</span><br><span class="line">String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString()；</span><br><span class="line">System.out.println(str2.intern() == str2)；</span><br></pre></td></tr></table></figure><blockquote><p>这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。</p><p>产生差异的原因是：<br>在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<br>而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为”java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</p></blockquote><h2 id="HotSpot对象"><a href="#HotSpot对象" class="headerlink" title="HotSpot对象"></a>HotSpot对象</h2><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p><img src="http://7xokux.com1.z0.glb.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98.png" alt=""></p><blockquote><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p></blockquote><ul><li>对象头<ul><li>对象自身运行时数据</li><li>类型指针, 用于确定对象是哪个类的实例. 但并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身. (后面说明). 另外，如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。</li></ul></li><li>实例数据, 本身的字段或者是继承的字段都要记录. 字段顺序受VM分配策略参数(FieldsAllocationStyle)和字段在代码中的定义顺序影响. 详见书中说明.</li><li>对齐填充, 并不一定存在. 。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ul><h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><p>两种方式</p><ul><li>使用句柄访问. Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息.</li><li>使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址.</li></ul><p>优劣对比:</p><ul><li>使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾<br>收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</li><li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销.</li></ul><p>HotSpot使用的是第二种, 直接指针.</p><hr><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="http://ifeve.com/java-permgen-removed/" target="_blank" rel="noopener">Java PermGen 去哪里了? | 并发编程网 – ifeve.com</a></li><li><a href="https://www.ibm.com/support/knowledgecenter/en/SSYKE2_7.0.0/com.ibm.java.lnx.70.doc/diag/appendixes/cmdline/commands_jvm.html" target="_blank" rel="noopener">Java command-line options - IBM Knowledge Center</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&amp;lt;深入理解Java虚拟机&amp;gt; 第二版, 第二章摘录 + 笔记.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;运行时数据区&quot;&gt;&lt;a href=&quot;#运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区&quot;&gt;&lt;/a&gt;运行时数据区&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://shibinfei.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrent - AQS &amp; FutureTask</title>
    <link href="https://shibinfei.github.io/2018/02/15/Java%20Concurrent%20-%20AQS%20&amp;%20FutureTask/"/>
    <id>https://shibinfei.github.io/2018/02/15/Java Concurrent - AQS &amp; FutureTask/</id>
    <published>2018-02-15T04:56:36.813Z</published>
    <updated>2018-03-02T06:53:22.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>基于Java1.6, 前后的版本实现都有所不同.</p><h3 id="确定入口"><a href="#确定入口" class="headerlink" title="确定入口"></a>确定入口</h3><p>在通常情况下, 我们是配合线程池获取一个<code>Future</code>的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;;</span><br><span class="line">Future&lt;Integer&gt; future = Executors.newSingleThreadExecutor().submit(callable);</span><br></pre></td></tr></table></figure></p><p>观察<code>submit</code>方法内部, 不考虑”池”的概念实际上等同于下面操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RunnableFuture&lt;Integer&gt; runnableFuture = new FutureTask&lt;&gt;(callable);</span><br><span class="line">new Thread(runnableFuture).start();</span><br></pre></td></tr></table></figure><p><code>RunnableFuture</code>本身实现了<code>Runnable</code>和<code>Future</code>.  从而可以确定<code>FutureTask</code>的两个重要入口方法: <code>run</code>, <code>get</code>.     </p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>观察<code>FutureTask</code>内部, 同样有一个<code>Sync</code>. 和<code>CountDownLatch</code>相似, <code>FutureTask</code>本身也是个共享的同步工具. 由于一个线程被<code>unpark</code>后, 会继续传播<code>PROPAGATE</code>, 所以当<code>FutureTask</code>中的任务执行完成后, 所有调用<code>get</code>方法的线程都会退出阻塞.  <code>CountDownLatch</code>中<code>state</code>表示数量, 而在<code>FutureTask</code>则表示生命周期的状态:</p><ul><li>READY = 0 刚刚<code>new FutureTask</code>后的状态.</li><li>RUNNING = 1</li><li>RAN = 2 表示执行完毕</li><li>CANCELED = 4</li></ul><p>如果强行类比的话, 那么<code>get</code>就对应<code>CountDownLatch</code>的<code>await</code>. <code>run</code>/<code>cancel</code>则对应<code>countDown</code>.</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>调用关系如下:</p><p><code>FutureTask#get</code> -&gt; <code>Sync#innerGet</code> -&gt; <code>AQS#acquireSharedInterruptibly(0)</code></p><p>根据我们之前的了解, 如果没有<code>tryAcquireShared(0)</code>成功, 则当前线程会被挂起. 在此处, <code>tryAcquireShared</code>的参数是没有任何意义的, 所以形参被取名叫<code>ignore</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int ignore) &#123;</span><br><span class="line">    return innerIsDone() ? 1 : -1;// 大于等于0 表示acquire成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>innerIsDone</code>大致为判断了状态是否为<code>RAN</code>或者<code>CANCELED</code>, 也就是说, 当其他线程将<code>state</code>设置为这两种状态之后, 等待线程才能结束运行. 当等待线程被唤醒后, 会做两个判断, 代码非常简单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (getState() == CANCELLED)</span><br><span class="line">     throw new CancellationException();</span><br><span class="line">if (exception != null)</span><br><span class="line">     throw new ExecutionException(exception);</span><br><span class="line">return result;</span><br></pre></td></tr></table></figure><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p><code>FutureTask#run</code> 中仅为调用 <code>Sync#innerRun</code>. 其中执行了<code>callable#call</code>, 没有异常则<code>set</code>, 反之则<code>setException</code>. 分别对应<code>Sync#innerSet</code>, <code>Sync#innerSetException</code>.     </p><p>观察两个方法, 其中的重要内容就是把<code>state</code>CAS为<code>RAN</code>, 并<code>doReleaseShared(0)</code>.  在<code>CountDownLatch</code>中有提到过这个方法, 子类的重点在于<code>tryReleaseShared</code>是如何实现的, 一定是返回<code>true</code>的, 且内容非常简单粗暴:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int ignore) &#123;</span><br><span class="line">    runner = null;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 这个方法的参数同样是无意义的. 其中的<code>runner</code>指的是执行<code>FutureTask</code>的线程, 即调用<code>set</code>,<code>setException</code>的线程. 实际上刚刚的<code>innerIsDone</code>除了判断状态之外, 还要求<code>runner == null</code>, 对应地, 他在<code>tryReleaseShared</code>这里被置为<code>null</code>.</p><h2 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h2><p>大体和<code>set</code>, <code>setException</code>一致, 都是将<code>state</code>CAS为一个值, 此处为<code>CANCELED</code>. 并且执行<code>doReleaseShared</code>. 除次之外, 如果为<code>cancel(true)</code>还会根据参数对执行任务的线程进行<code>interrupt</code>. 但是我们知道<code>interrupt</code>不一定成功, 观察下面的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">Callable&lt;Integer&gt; callable = () -&gt; &#123;</span><br><span class="line">spinFor(4, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(&quot;Done&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RunnableFuture&lt;Integer&gt; runnableFuture = new FutureTask&lt;&gt;(callable);</span><br><span class="line">new Thread(runnableFuture).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);// ensure the other thread has started</span><br><span class="line">runnableFuture.cancel(true);</span><br><span class="line">System.out.println(runnableFuture.get(3, TimeUnit.SECONDS));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void spinFor(long duration, TimeUnit timeUnit) &#123;</span><br><span class="line">long nanos = TimeUnit.NANOSECONDS.convert(duration, timeUnit);</span><br><span class="line">long lastTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">while (System.nanoTime() - lastTime &lt; nanos) &#123;</span><br><span class="line">// nothing</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现, <code>cancel</code>之后, <code>get</code>线程马上就得到响应, 抛出异常了. 而执行线程仍然要在等待几秒后执行完.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;基于Java1.6, 前后的版本实现都有所不同.&lt;/p&gt;
&lt;h3 id=&quot;确定入口&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Concurrent" scheme="https://shibinfei.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrent - AQS &amp; CountDownLatch</title>
    <link href="https://shibinfei.github.io/2018/02/14/Java%20Concurrent%20-%20AQS%20&amp;%20CountDownLatch/"/>
    <id>https://shibinfei.github.io/2018/02/14/Java Concurrent - AQS &amp; CountDownLatch/</id>
    <published>2018-02-14T14:18:58.187Z</published>
    <updated>2018-02-14T14:19:27.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><code>CountDownLatch</code>本身实现非常简单, 观察内部几乎所有方法都是直接调用AQS. 先看下它的典型用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">Runnable wait = () -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">latch.await();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread1 = new Thread(wait);</span><br><span class="line">thread1.start();</span><br><span class="line"></span><br><span class="line">Thread thread2 = new Thread(wait);</span><br><span class="line">thread2.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(100);// ensure thread1, thread2 start first</span><br><span class="line"></span><br><span class="line">Runnable countDown = () -&gt; &#123;</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread thread3 = new Thread(countDown);</span><br><span class="line">thread3.start();</span><br><span class="line"></span><br><span class="line">Thread thread4 = new Thread(countDown);</span><br><span class="line">thread4.start();</span><br></pre></td></tr></table></figure><p>对比<code>CountDownLatch</code>和<code>Worker</code>, 前者的<code>await</code>有些类似后者的<code>lock</code>, 而<code>countDown</code>类似<code>unlock</code>. 然而<code>Worker</code>是一种排他的同步工具, 而<code>CountDownLatch</code>则不是. 在上面的栗子中, <code>thread1</code>, <code>thread2</code>都会处于等待状态, 直到<code>thread3</code>, <code>thread4</code>执行完成.</p><p>根据上面的代码可以确定三个入口: 构造方法, <code>await</code>, <code>countDown</code>.  观察<code>CountDownLatch</code>的实现, 其中包含一个继承AQS的类<code>Sync</code>. 构造方法中, 只是设置<code>state</code>值; 传入的参数<code>count</code>即为AQS的<code>state</code>.   <code>countDown</code>方法中将<code>state</code>减一, 为0时<code>await</code>的线程即将结束等待.</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>如图:</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/CountDownLatch-Flowchart.png" alt=""></p><p>如果对比<code>Worker#lock</code>的流程图, 可以发现两者的结构很类似. 实际上, 很多方法都是可以一一对应,  在后面会列一个表格出来. 图中<code>tryAcquireShared</code>由子类实现, 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return (getState() == 0) ? 1 : -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>入口处如果<code>getState != 0</code>(实际上就是大于0), 那么就直接进入等待队列. 否则<code>getState == 0</code>, 实际上就不需要等待了, 直接<code>return</code></li><li>循环中, <code>getState == 0</code>, 即可以退出循环.</li></ul><p>综上, <code>tryAcquireShared</code>的结果大于0, 即表示acquire成功.</p><p><code>doReleaseShared</code>方法, 在下文<code>countDown</code>处说明.</p><h3 id="await-long-timeout-TimeUnit-unit"><a href="#await-long-timeout-TimeUnit-unit" class="headerlink" title="await(long timeout, TimeUnit unit)"></a>await(long timeout, TimeUnit unit)</h3><p>这个重载方法和<code>await</code>区别不大. 它内部调用的是<code>AQS#doAcquireSharedNanos</code>. 观察其中代码可以发现几乎没有任何区别, 只不过多了时间控制. 其中值得注意的是, 如果时间小于<code>spinForTimeooutThreadhold</code>, 则通过自旋(即循环), 否则通过LockSupport.partNanos来实现, 这样实现是处于性能考虑, 注释中亦有说明.</p><h2 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h2><p><code>CountDownLatch#countDown</code>即调用<code>Sync#releaseShared(1)</code>. 其中代码很短:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (tryReleaseShared(1)) &#123;</span><br><span class="line">    doReleaseShared();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br></pre></td></tr></table></figure></p><p>而<code>tryReleaseShared</code>的内容可以概括为: 尝试将<code>state</code>减一, 如果成功则返回<code>true</code>.  </p><p>如果<code>tryReleaseShared</code>成功, 则调用<code>doReleaseShared</code>. 此方法在上文也有提到, 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Ensure that a release propagates, even if there are other</span><br><span class="line">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="line">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">     * ensure that upon release, propagation continues.</span><br><span class="line">     * Additionally, we must loop in case a new node is added</span><br><span class="line">     * while we are doing this. Also, unlike other uses of</span><br><span class="line">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">     * fails, if so rechecking.</span><br><span class="line">     */</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>仅当<code>h == head</code>时才能跳出循环. 也就是说如果执行期间<code>head</code>被修改了, 需要重新执行操作.</li><li>如果<code>head.waitStatus</code>为<code>SIGNAL</code>, 则将其设置CAS为0, 并<code>unpark</code>其后置节点.</li><li>如果<code>head.waitStatus</code>为0, 则将其设置为<code>PROPAGATE</code>, 进入下次循环. 这里比较值得说明一下, 在我们刚刚设想的理想状态下, <code>head.waitStatus</code>是应该为<code>SIGNAL</code>的. 为0说明此时还没有其他节点进来, TODO</li></ul><h2 id="整体过程Review"><a href="#整体过程Review" class="headerlink" title="整体过程Review"></a>整体过程Review</h2><p>通过几个重要的变量, 来说明下整个过程的数据变化:</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/CountDownLatch.png" alt=""></p><ul><li>当<code>Thread3</code>未开始执行时, <code>state == 2</code>, <code>Thread3</code>第一次<code>countDown</code>, <code>state</code>只是变成1, 所以<code>tryReleaseShared</code>返回<code>false</code>.</li><li>当<code>Thread4</code>再次<code>countDown</code>时, 才返回<code>true</code>. 此时, 调用<code>doReleaseShared</code>. <code>Thread1</code>被<code>unpark</code>,  跳出循环. 回到<br><code>doAcquireSharedInterruptibly</code>, 随后执行<code>setHeadAndPropagate</code>,其中再次执行了doReleaseShared, 从而<code>Thread2</code>也被唤醒.</li></ul><h2 id="与Worker对比"><a href="#与Worker对比" class="headerlink" title="与Worker对比"></a>与Worker对比</h2><p><img src="http://7xokux.com1.z0.glb.clouddn.com/Worker%20&amp;%20CountDownLatch.png" alt=""></p><hr><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer-3" target="_blank" rel="noopener">JavaDoop - 一行一行源码分析清楚 AbstractQueuedSynchronizer (三)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;本身实现非常简单, 观察内部几乎所有方
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Concurrent" scheme="https://shibinfei.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrent - AQS &amp; Worker</title>
    <link href="https://shibinfei.github.io/2018/01/30/Java%20Concurrent%20-%20AQS%20&amp;%20Worker/"/>
    <id>https://shibinfei.github.io/2018/01/30/Java Concurrent - AQS &amp; Worker/</id>
    <published>2018-01-30T06:58:49.305Z</published>
    <updated>2018-02-01T03:27:39.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h2><p>之前提到过, <code>ThreadPoolExecutor</code>的内部类<code>Worker</code>维护了一个非常基本的锁结构. 方法不多, 可以由名知义:</p><pre><code>- lock- tryLock- unlock- isLocked</code></pre><p><code>Worker</code>本身继承了<code>AbstractQueuedSynchronizer</code>(AQS)来实现上述功能的. 事实上, AQS是Java中数个并发工具的基础, 功能也比较复杂. 我们先从这些并发工具中最简单的<code>Worker</code>开始, 之后逐步递进:</p><pre><code>- ThreadPoolExecutor#Worker- CountDownLatch- Semaphore- FutureTask (JDK 1.6)- ReentrantLock- ConditionObject- ReadWriteReentrantLock- AQS总结</code></pre><h2 id="2-一个最简单的独占锁"><a href="#2-一个最简单的独占锁" class="headerlink" title="2. 一个最简单的独占锁"></a>2. 一个最简单的独占锁</h2><p>我们可以基于CAS实现一种锁. 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * @author shibinfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CASLock &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 锁状态: false 表示当前没有被占用, true表示被占用</span><br><span class="line"> */</span><br><span class="line">private AtomicBoolean lockState = new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 当前持有锁的线程</span><br><span class="line"> */</span><br><span class="line">private Thread lockHolder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 尝试获取锁, 如果获取成功返回true, 获取失败立即返回false</span><br><span class="line"> * 可重入:</span><br><span class="line"> * @return true if success</span><br><span class="line"> */</span><br><span class="line">public boolean tryLock() &#123;</span><br><span class="line">if (lockState.get() == false) &#123;</span><br><span class="line">if (lockState.compareAndSet(false, true)) &#123;</span><br><span class="line">lockHolder = Thread.currentThread();</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if (lockHolder == Thread.currentThread()) &#123;</span><br><span class="line">// 同一个线程重入</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 解除当前线程锁定</span><br><span class="line"> */</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">if (Thread.currentThread() != lockHolder) &#123;</span><br><span class="line">throw new IllegalMonitorStateException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lockHolder = null;</span><br><span class="line">lockState.set(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类比我们的布尔变量<code>lockState</code>, AQS中使用的是一个整形字段 - <code>state</code>. 在互斥(即同时只能由一个线程持有锁)的场景下, <code>state</code>可能的取值只有0 / 1两种, 分别对应<code>false</code>, <code>true</code>.</li><li><code>tryLock</code>只是简单的尝试获取锁,  而在实际的<code>lock</code>方法中, 等待获取锁的线程都是被阻塞住的. 而这些线程的引用, 被维护于一个队列结构中.</li></ul><h2 id="3-A-Thread-Safe-Queue"><a href="#3-A-Thread-Safe-Queue" class="headerlink" title="3. A Thread-Safe Queue"></a>3. A Thread-Safe Queue</h2><p>AQS中另一个主体是一个基于双向链表的队列结构. 不考虑AQS逻辑, 实现如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A queue based on doubly linked list and compare-and-set pattern</span><br><span class="line"> *</span><br><span class="line"> * @author shibinfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ThreadSafeQueue &#123;</span><br><span class="line"></span><br><span class="line">private volatile AtomicReference&lt;Node&gt; head;</span><br><span class="line"></span><br><span class="line">private volatile AtomicReference&lt;Node&gt; tail;</span><br><span class="line"></span><br><span class="line">public ThreadSafeQueue() &#123;</span><br><span class="line">Node initialNode = new Node();</span><br><span class="line">head.set(initialNode);</span><br><span class="line">tail.set(initialNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void enqueue(Node node) &#123;</span><br><span class="line">Node tailNode = tail.get();</span><br><span class="line">for (;;) &#123;</span><br><span class="line">node.prev = tailNode;</span><br><span class="line">if (tail.compareAndSet(tailNode, node)) &#123;</span><br><span class="line">tailNode.next = node;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Node &#123;</span><br><span class="line">volatile Node prev;</span><br><span class="line">volatile Node next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始状态下, <code>head</code>, <code>tail</code>指向同一个节点. 如果没有出队列操作, 只是修改<code>tail</code>引用的节点.  观察<code>enqueue</code>方法, 思路和<code>Atomic</code>工具中的<code>getAndSet</code>思路是一致的. 示例中的类和变量在AQS中都可以找到对应.</p><h2 id="4-Worker"><a href="#4-Worker" class="headerlink" title="4. Worker"></a>4. Worker</h2><p>AQS是一个抽象类. 其他工具都是以继承的方式覆盖AQS的几个钩子方法.</p><h3 id="4-1-tryLock"><a href="#4-1-tryLock" class="headerlink" title="4.1 tryLock"></a>4.1 tryLock</h3><p><code>Worker#tryLock</code>和我们的<code>CASLock</code>的基本思想是一致的, 即通过一个原子变量来表示当前锁的状态, 只不过<code>CASLock</code>中使用的是<code>true/false</code>, 而<code>Worker</code>中使用的是<code>1/0</code>, 维持这个状态的是继承于AQS的<code>state</code>字段.</p><p>从下面的流程图可以看出来整体逻辑非常简单. 从这里开始, 稍微值得关注是一个问题是哪些方法是<code>Worker</code>重载的, 而哪些是继承的.</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/TheadPoolExecutor-Worker-tryLock.png" alt=""></p><p>当成功拿到锁之后, 会将<code>exclusiveOwnerThread</code>设为当前线程, 根据名称可以看出来, 仅当独占时才会用到此变量.</p><h3 id="4-2-isLocked"><a href="#4-2-isLocked" class="headerlink" title="4.2 isLocked"></a>4.2 isLocked</h3><p>同样是基于<code>state</code>的简单逻辑: 即<code>AQS#getState() == 0</code>.</p><h3 id="4-3-lock"><a href="#4-3-lock" class="headerlink" title="4.3 lock"></a>4.3 lock</h3><p><code>lock</code>的方法比较复杂. 如图:<br><img src="http://7xokux.com1.z0.glb.clouddn.com/ThreadPoolExecutor-Worker%23Lock.png" alt=""></p><ul><li>进入方法时, 首先进行了一次<code>tryAcquire</code>, 如果成功那真是最好的结局. 否则开始”等待”.</li><li>等待指的就是当前线程被抽象为一个节点, 进入了队列尾端(See <code>addWaiter</code>) . 就开始”等待”, 随即进入<code>AQS#acquireQueued</code>逻辑.</li><li><code>acquireQueued</code>内, 线程进入了一个循环体系中.<ul><li>仅当满足 <strong> 当前节点前面节点为头结点 </strong> 并且 <strong> tryAcquire成功 </strong>时才能跳出循环.  此时为成功获取锁.</li><li>不满足上述条件线程, 会被挂起(park).  如果一个线程此时无法获取锁, 注意它的前置节点<code>waitStatus</code>初始为0, <code>shouldParkAfterFailedAcquire</code>方法中会将其置为<code>Node.SIGNAL</code>. 而在下次循环中, 此线程才被真正挂起.</li></ul></li></ul><p>看到这里, 如果对于下面几个问题有疑问, 先保留.</p><ul><li><code>waitStatus</code>是干什么的?</li><li>线程在<code>parkAndCheckInterrupt</code>中, 调用的是<code>Thread.interrupted()</code>. 如我们所知, 这个方法会清楚并返回线程的中断状态. 而<code>acquireQueued</code>中如果曾经被中断过, 就会把中断状态返回给<code>acquire</code>, <code>acquire</code>中调用<code>selfInterrupt</code>, 重新将当前线程中断状态设置为`true</li><li>何时执行到<code>acquireQueued</code>内部<code>final</code>块调用的<code>cancelAcquire</code>?. 在<code>acquireQueue</code>中的循环, 只有一个出口即满足<code>p == head &amp;&amp; tryAcquire(arg)</code>. 而此时<code>fail</code>将一定为<code>false</code>, 所以看似一定不会<code>cancelAcquire</code></li></ul><hr><p> <code>Worker</code>看似是一个很典型的锁. 但是注意的是它的构造方法有这么一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(-1); // inhibit interrupts until runWorker</span><br></pre></td></tr></table></figure></p><p>初始情况<code>state == -1</code>, 所以<code>compareAndSet(0, 1)</code>是永远无法成功的, 后面对此进行说明. 这里先假设, 初始状态<code>state == 0</code>.  基于一个简单的示例说明数据变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Worker worker = new Worker();</span><br><span class="line">worker.lock();</span><br><span class="line"></span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">worker.lock();</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">worker.unlock();</span><br></pre></td></tr></table></figure><p>这个过程的数据变化如下图(Step 3可以留到下节后再回来看):</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/WorkerLockExample.png" alt=""></p><h3 id="4-4-unlock"><a href="#4-4-unlock" class="headerlink" title="4.4 unlock"></a>4.4 unlock</h3><p>假如线程A获取了锁, 线程B在等待. 当前专题下</p><ul><li><code>Worker</code>的<code>tryRelease</code>方法是一定会成功的.</li></ul><p>// TODO 流程图 + 实例</p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>虽然前文曾经表示可以暂时将<code>Worker</code>看作一个<code>ReentrantLock</code>, 然后实际上两者行为还是有一些不一致的. 先来看下, <code>ThreadPoolExecutor</code>都有哪里调用了<code>Worker</code>的锁行为.</p><ol><li>构造方法设置<code>state</code>为-1.</li><li><code>runWorker</code>时先<code>unlock</code></li><li>在循环中, 每个task执行前后<code>lock</code>, <code>unlock</code></li><li><code>interruptIdleWorkers</code>前后<code>tryLock</code>, <code>unlock</code></li></ol><p>第1, 2点注释也有说明, 1是为了禁止被<code>interrupt</code>, 2是允许<code>interrupt</code>.  而且由于第一点的存在, 如果当做普通锁, 上来就<code>lock()</code>的话, 是会一直阻塞的, 所以前面把初始状态设置为0.</p><p>在大部分情况下, Woker这个同步工具并没有涉及到多线程间通信, 它只被线程池中的线程持有. 而当主线程试图<code>interrupt</code>线程池中线程时, 才有多个线程对锁的争用.  <code>ThreadPoolExecutor</code>中</p><ul><li><code>shutdown</code>中会调用<code>interruptIdleWorkers</code>(<code>tryLock</code>成功再<code>interrupt</code>)</li><li><code>shutdownNow</code>调用<code>interruptWorkers</code>(对所有线程都<code>interrupt</code>).</li></ul><p>这两个方法中一个会判断<code>getState() &gt;= 0</code>, 一个会<code>tryLock()</code>. 所以当<code>getState() == -1</code>时两个操作都无效.</p><p>另外, <code>Worker</code>的<code>tryRelease</code>方法很粗暴. 如果有<code>ReentrantLock</code>使用经验会发现, 如果某线程不是锁的持有者但又试图<code>unlock</code>, 会抛出<code>IllegalMonitorStateException</code>.  而<code>Worker</code>则不然, A线程<code>lock</code>后B线程也可以<code>unlock</code>.</p><p>单独提取<code>Worker</code>中部分同步相关代码, 可以注意下那些方法是<code>Override</code>的, 以及暴露的方法和AQS的对应关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">public class Worker extends AbstractQueuedSynchronizer &#123;</span><br><span class="line"></span><br><span class="line">public Worker() &#123;</span><br><span class="line">super();</span><br><span class="line">setState(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected boolean isHeldExclusively() &#123;</span><br><span class="line">return getState() != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected boolean tryRelease(int unused) &#123;</span><br><span class="line">setExclusiveOwnerThread(null);</span><br><span class="line">setState(0);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void lock() &#123;</span><br><span class="line">acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean tryLock() &#123;</span><br><span class="line">return tryAcquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void unlock() &#123;</span><br><span class="line">release(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isLocked() &#123;</span><br><span class="line">return isHeldExclusively();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h2&gt;&lt;p&gt;之前提到过, &lt;code&gt;ThreadPoolExecutor&lt;/cod
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Concurrent" scheme="https://shibinfei.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrent - DelayQueue</title>
    <link href="https://shibinfei.github.io/2018/01/29/Java%20Concurrent%20-%20DelayQueue/"/>
    <id>https://shibinfei.github.io/2018/01/29/Java Concurrent - DelayQueue/</id>
    <published>2018-01-29T12:57:34.124Z</published>
    <updated>2018-01-31T11:05:23.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><ul><li>阅读前需要了解<code>DelayQueue</code>的基本使用. 可以参考 <a href="http://www.baeldung.com/java-delay-queue" target="_blank" rel="noopener">Guide to DelayQueue | Baeldung</a></li></ul><h2 id="SimpleDelayQueue"><a href="#SimpleDelayQueue" class="headerlink" title="SimpleDelayQueue"></a>SimpleDelayQueue</h2><p><code>DelayQueue</code>的基本思想很简单:</p><ul><li>内部容器为一个优先队列, 优先条件为出队列时间. 即应该出队列的时间越早越优先.</li><li>通过<code>Condition#awaitNanos</code>来实现时间上的延迟. 举例, 假设队列中只有一个元素, 需要延迟1秒. 那么试图获取此元素的线程就需要<code>await(1, TimeUnit.SECONDS)</code></li></ul><p><code>DelayQueue</code>的成员非常少, 都列在下方. 其中的<code>leader</code>可以暂时忽略.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private transient final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">private Thread leader = null;</span><br><span class="line"></span><br><span class="line">private final Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure><p>值得注意的一点是, 虽然<code>DelayQueue</code>是<code>BlockingQueue</code>的实现, 但是<code>DelayQueue</code>的所有插入方法都不会阻塞, <code>put</code>方法也只是调用了<code>offer</code>而已:</p><blockquote><p> Inserts the specified element into this delay queue. As the queue is unbounded this method will never block.</p></blockquote><p>如果不考虑<code>leader</code>, 可以仅仅<strong>基于<code>lock</code>, <code>awailable</code>,<code>q</code>实现一个更加简单的延迟队列</strong>. 我们只实现两个最核心的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A delay queue without leader</span><br><span class="line"> * @author shibinfei</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;E&gt;</span><br><span class="line"> */</span><br><span class="line">public class SimpleDelayQueue&lt;E extends Delayed&gt; &#123;</span><br><span class="line"></span><br><span class="line">private final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">private final Condition available = lock.newCondition();</span><br><span class="line"></span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">q.offer(e);</span><br><span class="line"></span><br><span class="line">if (q.peek() == e) &#123;</span><br><span class="line">available.signal();</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line">try &#123;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">E first = q.peek();</span><br><span class="line">if (first == null) &#123;</span><br><span class="line">available.await();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">long delay = first.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">if (delay &lt;= 0) &#123;</span><br><span class="line">return q.poll();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">available.awaitNanos(delay);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">if (q.peek() != null) &#123;</span><br><span class="line">available.signal();</span><br><span class="line">&#125;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h3><p><code>offer</code>主体可以说是非常简单了:</p><ul><li>向优先队列中插入元素</li><li>如果刚刚插入的元素为队列头部. 那么则对其他线程进行<code>signal</code>.  可以猜想在典型的生产线程/消费线程情况下, 没有拿到元素的线程应该是在<code>await</code>状态, 所以<code>signal</code>唤醒其中一个消费线程是必要的. 而如果元素不是队列的head, 那么通常表示此元素还不需要出队列, 没有必要白白唤醒一个线程. (TODO)</li></ul><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p><code>take</code>的逻辑可以简单看一眼. 如果感觉不清晰没关系, 后面的举例更明了. 也可以参考流程图:</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/DelayQueue-Simplified.png" alt=""></p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>假设实现一种延迟指定秒的<code>Delay</code>, <code>new FixedSecondsDelay(5)</code>表示延迟5秒. 如果对实现感兴趣可以看如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 一种 &#123;@code Delayed&#125; 实现: 在指定秒之后可以出队列</span><br><span class="line"> * @author shibinfei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class FixedSecondsDelay implements Delayed &#123;</span><br><span class="line"></span><br><span class="line">// 可以出队列的时间</span><br><span class="line">private Date outTime;</span><br><span class="line"></span><br><span class="line">public Date getOutTime() &#123;</span><br><span class="line">return outTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public FixedSecondsDelay(long secondsToBeReady) &#123;</span><br><span class="line">this.outTime = new Date(System.currentTimeMillis() + secondsToBeReady * 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Delayed o) &#123;</span><br><span class="line">return outTime.compareTo(((FixedSecondsDelay)o).getOutTime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">return unit.convert(outTime.getTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DelayQueue&lt;FixedSecondsDelay&gt; delayQueue = new DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">delayQueue.take();// wait if elements can&apos;t be polled</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &quot;Thread&quot; + i).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(2); // 保证前两个线程先执行</span><br><span class="line">delayQueue.put(new FixedSecondsDelay(2));// can be polled after 2 seconds</span><br></pre></td></tr></table></figure><p>整个过程中涉及到了三个线程, 分别为循环中创建的消费线程<code>Thread0</code>, <code>Thread1</code>和主线程<code>Main</code>. 接下来对整个流程进行流水账说明:</p><pre><code>1. `Thread0`获取锁之后, 马上进入了`await`, 而此操作释放了锁, 则`Thread1`进入, 同样进入`await`状态.2. 接下来`Main`线程, 放入了一个两秒后可以出队列的元素,   此时只有一个元素, 故亦为队列头元素. 所以会`signal`一个等待线程, 假设为`Thread1`3. 被唤醒的`Thread1` 进入了下次循环, 而此时头部元素不为空, 但是还没到时间, 仍需2秒才能出队列, 故`Thread1`开始`awaitNanos(delay)` (2秒) , 结束`awaitNanos`之后, 下次循环即可取出元素. 随机返回.</code></pre><p>制造一个更加复杂一点的场景, <code>delayQueue.put(new FixedSecondsDelay(2));</code>之后再追加一个<code>delayQueue.put(new FixedSecondsDelay(5));</code>. 那么和上方, 第1, 2步是相同的. 第3步有一些差别:</p><pre><code>3. 5秒出队列的元素, 由于不是队列头, 所以并没有去唤醒任一线程. 但是当`Thread1`结束之后, 会去`signal`等待的`Thread0`来继续处理此元素.  </code></pre><h2 id="Leader-follower"><a href="#Leader-follower" class="headerlink" title="Leader - follower"></a>Leader - follower</h2><h3 id="第一印象"><a href="#第一印象" class="headerlink" title="第一印象"></a>第一印象</h3><blockquote><p>Thread designated to wait for the element at the head of the queue.  This variant of the Leader-Follower pattern (<a href="http://www.cs.wustl.edu/~schmidt/POSA/POSA2/" target="_blank" rel="noopener">http://www.cs.wustl.edu/~schmidt/POSA/POSA2/</a>) serves to minimize unnecessary timed waiting.  When a thread becomes the leader, it waits only for the next delay to elapse, but other threads await indefinitely.</p></blockquote><p>这是关于<code>leader</code>的前半部分注释. 实际上”timed_waiting”以及”waits only for the next delay to elapse”的实际行为都是<code>awaitNanos</code>. 相应的, “await indefinitely”即<code>await</code>. 加深一下印象:</p><pre><code>- leader表示等待处理队列head元素的线程- 减少不必要的`awaitNanos`.</code></pre><p>总体来讲, <code>leader</code>的作用就是尽量让线程处于<code>await</code>状态, 而不是<code>await</code>. 可想而知这基于一个前提: <code>awaitNanos</code>会带来不必要的性能消耗.</p><h3 id="如何减少awaitNanos"><a href="#如何减少awaitNanos" class="headerlink" title="如何减少awaitNanos"></a>如何减少<code>awaitNanos</code></h3><p>对比<code>DelayQueue</code>和<code>SimpleDelayQueue</code>.  前者多了这些判断</p><ul><li><code>offer</code> 中如果为头元素, 会将<code>leader</code>设置为<code>null</code></li><li><code>take</code>中判断<code>leader != null</code>, 会进入<code>await</code>.  并且<code>awaitNanos</code>前后分别会占用/放弃<code>leader</code>位置.</li></ul><p>当面临如下场景时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DelayQueue&lt;Delayed&gt; delayQueue = new DelayQueue&lt;&gt;();</span><br><span class="line">Delayed delayed = new FixedSecondsDelay(10);// 10 seconds to be ready</span><br><span class="line">delayQueue.offer(delayed);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">delayQueue.take();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设两个线程为<code>Thread0</code>, <code>Thread1</code>.  其中一个先获取锁之后, 占用了<code>leader</code>, 开始<code>awaitNanos</code>. 而另一个线程判断当前<code>leader</code>不为空, 则进入了<code>await</code>状态. 相比之下<code>SimpleDelayQueue</code>在这种场景中, 两个线程都在<code>awaitNanos</code>.</p><h3 id="Leader-Summary"><a href="#Leader-Summary" class="headerlink" title="Leader Summary"></a>Leader Summary</h3><ul><li>在处理队列head的线程才能是<code>leader</code>. 如果队列head更换, 那么对应线程的<code>leader</code>位置就不保了.</li><li>一个线程成为<code>leader</code>之后, 它<code>awaitNanos</code>, 其他线程<code>await</code>(这句话在上面的case适用, 但是不是所有场景都如此)</li><li><code>leader</code>拿完元素走人之后, 要<code>signal</code>其他线程(follower).</li></ul><h2 id="TODO-md-感觉说的不够清楚"><a href="#TODO-md-感觉说的不够清楚" class="headerlink" title="TODO // md 感觉说的不够清楚"></a>TODO // md 感觉说的不够清楚</h2><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="http://www.baeldung.com/java-delay-queue" target="_blank" rel="noopener">Guide to DelayQueue | Baeldung</a></li><li><a href="https://stackoverflow.com/questions/48493830/what-exactly-is-the-leader-used-for-in-delayqueue" target="_blank" rel="noopener">What is Leader Used for in DelayQueue</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Foreword&quot;&gt;&lt;a href=&quot;#Foreword&quot; class=&quot;headerlink&quot; title=&quot;Foreword&quot;&gt;&lt;/a&gt;Foreword&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;阅读前需要了解&lt;code&gt;DelayQueue&lt;/code&gt;的基本使用. 可以参
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Concurrent" scheme="https://shibinfei.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrent - CopyOnWriteArrayList</title>
    <link href="https://shibinfei.github.io/2018/01/24/Java%20Concurrent%20-%20CopyOnWriteArrayList/"/>
    <id>https://shibinfei.github.io/2018/01/24/Java Concurrent - CopyOnWriteArrayList/</id>
    <published>2018-01-24T06:12:11.734Z</published>
    <updated>2018-01-31T11:05:19.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>copy-on-write容器在计算机世界常常出现, 如果不了解可以参考<a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">Java中的Copy-On-Write容器</a>. <code>CopyOnWriteArrayList</code>特性简要概括如下:</p><ul><li>内存中有可能存在两个数组, 写时占用更多存储空间.</li><li>写操作之间仍然是互斥的, 同一时刻仍然只有一个线程可以进行写操作.</li><li>写操作进行时会先复制出一个副本出去(假设为B), 读操作仍然读取原来的数据(假设为数组A). 即在数组A上就不再存在写操作, 所以读取时不需要加锁.</li></ul><p>根据其特性, 可以发现读取操作如<code>size</code>,<code>get</code>,<code>indexOf</code>, 几乎和平常的列表没有任何不同.</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在尝试实现RPC框架时, 需要使用一个列表来保存注册的Provider地址. 而Provider的数量实际上不会很大, 而且服务的上下线频率实际上非常低, 远远小于读取次数. 这种场景下正好使用<code>CopyOnWriteList</code>, 可以保证读取效率和<code>ArrayList</code>一致.  </p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p><code>CopyOnWriteArrayList</code>的实现主要基于两个Java并发机制, 即<code>ReentrantLock</code>和<code>volatile</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transient final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">private volatile transient Object[] array;</span><br></pre></td></tr></table></figure><p>前者负责为所有的写操作加锁, 后者保证修改数组引用后的可见性. 列举简单的<code>add</code>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;    // mark -&gt;</span><br><span class="line">        setArray(newElements);  // 修改array引用.</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在锁操作中, 复制当前数组, 最后修改array引用. 真 · copy-on-write而已. 而这里有一个本身特性带来问题, 即 <strong>此容器虽然最终一致, 但是确不是实时读写一致的</strong>.</p><p>假设线程A进入了写操作<code>add</code>, 另一个线程B同时读取.</p><ul><li>如果A线程已经执行了<code>setArray</code>, 那么根据<code>volatile</code>变量的特性, B线程当然可见.</li><li>然而由于读操作无锁, 假设A线程刚刚执行到标记<code>mark</code>的位置, 同时B线程进行读操作, 则明显读到的还是之前的数组.</li></ul><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>请看注释:</p><blockquote><p>Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a CopyOnWriteArrayList happen-before actions subsequent to the access or removal of that element from the CopyOnWriteArrayList in another thread.</p></blockquote><p>翻译:</p><p>内存一致性影响: 和其他并发集合一样, 在一个线程内, 如果某个操作在插入元素到<code>CopyOnWriteArrayList</code>之前发生, 那么此操作happpens-before于另一个线程中<code>CopyOnWriteArrayList</code>读写之后发生的操作.</p><p>真绕口.. happens-before比较好理解: A操作happens-beforeB操作, 即A执行的结果对于B可见. 对于上面这句注释, 没理解的话先放下, 继续看. 这段来自 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile" target="_blank" rel="noopener">JSR133 FAQ</a></p><h3 id="JSR133-FAQ"><a href="#JSR133-FAQ" class="headerlink" title="JSR133 FAQ"></a>JSR133 FAQ</h3><blockquote><p>Under the new memory model, it is still true that volatile variables cannot be reordered with each other. The difference is that it is now no longer so easy to reorder normal field accesses around them. Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f.</p></blockquote><p>翻译:</p><p>在新内存模型下, 相同之处是volatile变量之间仍然不能被重排序. 而差别在于volatile变量前后的其他变量重排序不再那么简单. 对于<code>volatile</code>变量的写操作和monitor释放有相同的效果, 对于<code>volatile</code>变量的读操作也和Monitor获取有相同效果. 实际上, 由于新的内存模型对于<code>volatile</code>变量和其他变量(无论是否为volatile)的重排序更严格, 当线程A写入<code>volatile</code>变量<code>f</code>时, 而线程B在读取<code>f</code>, 那么A可见的一切对B都可见.</p><p>文中举例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x = 0;</span><br><span class="line">  volatile boolean v = false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x = 42;</span><br><span class="line">    v = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v == true) &#123;</span><br><span class="line">      //uses x - guaranteed to see 42.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A线程调用<code>writer()</code>, B调用<code>reader()</code>. 由于<code>v</code>为<code>volatile</code>, 所以<code>v</code>之前的非volatile变量写操作<code>x = 42</code>对于线程B中的<code>x</code>读取一定可见.</p><h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><p>在<code>CopyOnWriteArrayList</code>中的一段看似较为奇怪的代码, 就是来保证刚刚的内存一致性的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">           if (oldValue != element) &#123;</span><br><span class="line">               int len = elements.length;</span><br><span class="line">               Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">               newElements[index] = element;</span><br><span class="line">               setArray(newElements);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Not quite a no-op; ensures volatile write semantics</span><br><span class="line">               setArray(elements);  ---&gt; 看这里</span><br><span class="line">           &#125;</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>即其中标注”看这里”的位置, 它的作用和<code>VolatileExample</code>中的<code>v</code>相同, 借用<code>volatile</code>变量来保证一致性. 引用<a href="https://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist" target="_blank" rel="noopener">stackoverflow</a>上面的一段示例, 实际上和<code>VolatileExample</code>非常相似:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// initial conditions</span><br><span class="line">int nonVolatileField = 0;</span><br><span class="line">CopyOnWriteArrayList&lt;String&gt; list = /* a single String */</span><br><span class="line"></span><br><span class="line">// Thread 1</span><br><span class="line">nonVolatileField = 1;                 // (1)</span><br><span class="line">list.set(0, &quot;x&quot;);                     // (2)</span><br><span class="line"></span><br><span class="line">// Thread 2</span><br><span class="line">String s = list.get(0);               // (3)</span><br><span class="line">if (s == &quot;x&quot;) &#123;</span><br><span class="line">    int localVar = nonVolatileField;  // (4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类比之下, 应该比较容易理解了. 虽然<code>nonVolatileField</code>非volatile, 但是操作(1)happens-before操作(4). 综上, <code>CopyOnWriteArrayList</code>通过<code>volatile</code>实现一种内存一致性影响.</p><hr><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">聊聊并发-Java中的Copy-On-Write容器 | 并发编程网 – ifeve.com</a></li><li><a href="https://stackoverflow.com/questions/28772539/why-setarray-method-call-required-in-copyonwritearraylist" target="_blank" rel="noopener">Why setArray() method call required in CopyOnWriteArrayList - Stack Overflow</a></li><li><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#volatile" target="_blank" rel="noopener">JSR-133 FAQ</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;&lt;p&gt;copy-on-write容器在计算机世界常常出现, 如果不了解可以参考&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Concurrent" scheme="https://shibinfei.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Java Tools - jstack</title>
    <link href="https://shibinfei.github.io/2018/01/05/Java%20Tools%20-%20jstack/"/>
    <id>https://shibinfei.github.io/2018/01/05/Java Tools - jstack/</id>
    <published>2018-01-05T06:52:41.772Z</published>
    <updated>2018-01-05T06:57:30.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Usage"><a href="#1-Usage" class="headerlink" title="1. Usage"></a>1. Usage</h2><p><code>jstack</code>是用来打印Stack trace的一个工具. 由JDK提供, 在<code>$JAVA_HOME/bin/</code>目录下. 对于一个Java进程来说, 可以使用<code>jps</code>, 或者<code>ps</code>命令获取进程ID. 假设进程ID为9876, 则下面的命令就可以dump出相关的线程信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 9876</span><br></pre></td></tr></table></figure></p><h2 id="2-Explanation"><a href="#2-Explanation" class="headerlink" title="2. Explanation"></a>2. Explanation</h2><p>举个栗子, 执行如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">Thread.sleep(1000000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看端口 <code>jps</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">13120 Test</span><br><span class="line">13122 Jps</span><br><span class="line">10674 bootloader.jar</span><br><span class="line">9042 ZooKeeperMain</span><br><span class="line">7076</span><br><span class="line">12727 Main</span><br></pre></td></tr></table></figure></p><p>Dump线程信息<code>jstack 13120</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.121-b13 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #9 daemon prio=9 os_prio=31 tid=0x00007fe05d850000 nid=0x1007 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Service Thread&quot; #8 daemon prio=9 os_prio=31 tid=0x00007fe05d042800 nid=0x4703 runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C1 CompilerThread2&quot; #7 daemon prio=9 os_prio=31 tid=0x00007fe05d039800 nid=0x4503 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread1&quot; #6 daemon prio=9 os_prio=31 tid=0x00007fe05d038800 nid=0x4303 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os_prio=31 tid=0x00007fe05d020000 nid=0x4103 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=31 tid=0x00007fe05d01f000 nid=0x3f0b runnable [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;Finalizer&quot; #3 daemon prio=8 os_prio=31 tid=0x00007fe05d012800 nid=0x3203 in Object.wait() [0x000070000ca60000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x0000000795588ec8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)</span><br><span class="line">- locked &lt;0x0000000795588ec8&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)</span><br><span class="line">at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)</span><br><span class="line"></span><br><span class="line">&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=31 tid=0x00007fe05c822800 nid=0x3003 in Object.wait() [0x000070000c95d000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;0x0000000795586b68&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.Object.wait(Object.java:502)</span><br><span class="line">at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">- locked &lt;0x0000000795586b68&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fe05d003800 nid=0x1a03 waiting on condition [0x000070000c34b000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at test.Test.main(Test.java:6)</span><br><span class="line"></span><br><span class="line">&quot;VM Thread&quot; os_prio=31 tid=0x00007fe05d809000 nid=0x2e03 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#0 (ParallelGC)&quot; os_prio=31 tid=0x00007fe05c800800 nid=0x2607 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#1 (ParallelGC)&quot; os_prio=31 tid=0x00007fe05c808800 nid=0x2803 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#2 (ParallelGC)&quot; os_prio=31 tid=0x00007fe05c809000 nid=0x2a03 runnable</span><br><span class="line"></span><br><span class="line">&quot;GC task thread#3 (ParallelGC)&quot; os_prio=31 tid=0x00007fe05c80a000 nid=0x2c03 runnable</span><br><span class="line"></span><br><span class="line">&quot;VM Periodic Task Thread&quot; os_prio=31 tid=0x00007fe05d015000 nid=0x4903 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 6</span><br></pre></td></tr></table></figure></p><p>注意, JVM仅仅启动一个用户线程. 即<code>main</code>线程. 除此之外都是JVM启动的线程, 可以大致看一下方便排错时排除. 以<code>main</code>线程为例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot; #1 prio=5 os_prio=31 tid=0x00007fe05d003800 nid=0x1a03 waiting on condition [0x000070000c34b000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at test.Test.main(Test.java:6)</span><br></pre></td></tr></table></figure><p>可以看到都是调用的stack信息, 主要信息都在前两行.</p><h3 id="2-1-Java-Thread-Name-amp-ID"><a href="#2-1-Java-Thread-Name-amp-ID" class="headerlink" title="2.1 Java Thread Name &amp; ID"></a>2.1 Java Thread Name &amp; ID</h3><p><code>&quot;main&quot; #1</code>分别表示Java线程的名称和ID. 在Java代码中可以通过<code>Thread#getName</code>, <code>Thead#getId</code>获取.</p><h3 id="2-2-线程优先级"><a href="#2-2-线程优先级" class="headerlink" title="2.2 线程优先级"></a>2.2 线程优先级</h3><p><code>prio=5</code>表示线程的优先级, 即<code>Thread#getPriority</code></p><h3 id="2-2-NID-amp-TID"><a href="#2-2-NID-amp-TID" class="headerlink" title="2.2 NID &amp; TID"></a>2.2 NID &amp; TID</h3><p><code>tid=0x00007fe05d003800 nid=0x1a03</code></p><ul><li>NID即Native thread ID, 与操作系统相关. 在Linux平台中指的是”light-weight process”. Linux下可以通过如下命令查看一个进程的线程ID:<br><code>ps -T -p $PID</code> // SPID列<br><code>top -H -p $PID</code>    // PID列</li><li>TID为C++层次的线程/Java线程地址.</li></ul><h3 id="2-3-Thread-State"><a href="#2-3-Thread-State" class="headerlink" title="2.3 Thread State"></a>2.3 Thread State</h3><p><code>java.lang.Thread.State: TIMED_WAITING</code>: 当前线程状态, 是一个枚举类. 可以直接看注释. 只有以下几种:</p><pre><code>- NEW- RUNNABLE- BLOCKED- WAITING- TIMED_WAITING- TERMINATED</code></pre><p>除了基本的状态之外还有一些更详细的描述信息<code>sleeping</code>,<code>waiting on condition [0x000070000c34b000]</code>. 如果发生死锁等事件也将在此体现.</p><h2 id="3-Best-Practice"><a href="#3-Best-Practice" class="headerlink" title="3. Best Practice"></a>3. Best Practice</h2><h3 id="3-1-寻找哪里阻塞"><a href="#3-1-寻找哪里阻塞" class="headerlink" title="3.1 寻找哪里阻塞"></a>3.1 寻找哪里阻塞</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在部署一个Web应用后, 向其发送请求, 但是一直没有响应. 最后查看Nginx日志查看上游超时了, 但是应用没有抛出异常.</p><h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>Dump的线程信息有一条内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">http--2801-4$1476360005&quot; #25 daemon prio=5 os_prio=0 tid=0x00007fa884011000 nid=0x6b67 runnable [0x00007fa87f532000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">- locked &lt;0x00000000910e2f20&gt; (a java.net.SocksSocketImpl)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">at java.net.Socket.connect(Socket.java:538)</span><br><span class="line">at sun.net.NetworkClient.doConnect(NetworkClient.java:180)</span><br><span class="line">at sun.net.www.http.HttpClient.openServer(HttpClient.java:432)</span><br><span class="line">at sun.net.www.http.HttpClient.openServer(HttpClient.java:527)</span><br><span class="line">- locked &lt;0x00000000910e2e98&gt; (a sun.net.www.http.HttpClient)</span><br><span class="line">at sun.net.www.http.HttpClient.&lt;init&gt;(HttpClient.java:211)</span><br><span class="line">at sun.net.www.http.HttpClient.New(HttpClient.java:308)</span><br><span class="line">at sun.net.www.http.HttpClient.New(HttpClient.java:326)</span><br><span class="line">at sun.net.www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:1202)</span><br><span class="line">at sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1138)</span><br><span class="line">at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1032)</span><br><span class="line">at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:966)</span><br><span class="line">at sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1316)</span><br><span class="line">- locked &lt;0x00000000910e2358&gt; (a sun.net.www.protocol.http.HttpURLConnection)</span><br><span class="line">at sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1291)</span><br><span class="line">- locked &lt;0x00000000910e2358&gt; (a sun.net.www.protocol.http.HttpURLConnection)</span><br><span class="line">at com.caucho.hessian.client.HessianProxy.sendRequest(HessianProxy.java:298)</span><br><span class="line">at com.caucho.hessian.client.HessianProxy.invoke(HessianProxy.java:166)</span><br><span class="line">at com.sun.proxy.$Proxy45.getSimilarity(Unknown Source)</span><br><span class="line">at com.coola.component.search.share.SearchClientNew.getSimilarity(SearchClientNew.java:78)</span><br><span class="line">at com.zhenai.website.modules.recommend.service.impl.RecommendServiceImpl.getGuessLike(RecommendServiceImpl.java:305)</span><br><span class="line">at com.zhenai.website.action.profile.ProfilePageAct.profileIndex(ProfilePageAct.java:524)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215)</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:745)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:685)</span><br><span class="line">at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:919)</span><br><span class="line">at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:851)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:953)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:844)</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:118)</span><br><span class="line">at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:829)</span><br><span class="line">at javax.servlet.http.HttpServlet.service(HttpServlet.java:95)</span><br><span class="line">at com.caucho.server.dispatch.ServletFilterChain.doFilter(ServletFilterChain.java:103)</span><br><span class="line">at com.zhenai.website.common.web.interceptor.OfflineFilter.doFilter(OfflineFilter.java:141)</span><br><span class="line">at com.caucho.server.dispatch.FilterFilterChain.doFilter(FilterFilterChain.java:87)</span><br><span class="line">at com.zhenai.commons.web.filter.SidFilter.doFilter(SidFilter.java:77)</span><br><span class="line">at com.caucho.server.dispatch.FilterFilterChain.doFilter(FilterFilterChain.java:87)</span><br><span class="line">at com.zhenai.commons.web.filter.XssFilter.doFilter(XssFilter.java:58)</span><br><span class="line">at com.caucho.server.dispatch.FilterFilterChain.doFilter(FilterFilterChain.java:87)</span><br><span class="line">at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:106)</span><br><span class="line">at com.caucho.server.dispatch.FilterFilterChain.doFilter(FilterFilterChain.java:87)</span><br><span class="line">at com.zhenai.commons.web.filter.IpBlackFilter.doFilter(IpBlackFilter.java:69)</span><br><span class="line">at com.caucho.server.dispatch.FilterFilterChain.doFilter(FilterFilterChain.java:87)</span><br><span class="line">at com.caucho.server.webapp.WebAppFilterChain.doFilter(WebAppFilterChain.java:187)</span><br><span class="line">at com.caucho.server.dispatch.ServletInvocation.service(ServletInvocation.java:265)</span><br><span class="line">at com.caucho.server.http.HttpRequest.handleRequest(HttpRequest.java:273)</span><br><span class="line">at com.caucho.server.port.TcpConnection.run(TcpConnection.java:682)</span><br><span class="line">- locked &lt;0x00000000b5d04cd8&gt; (a java.lang.Object)</span><br><span class="line">at com.caucho.util.ThreadPool$Item.runTasks(ThreadPool.java:743)</span><br><span class="line">at com.caucho.util.ThreadPool$Item.run(ThreadPool.java:662)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></p><p>可以很容易看出来, 是某个Http请求阻塞了.:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at com.coola.component.search.share.SearchClientNew.getSimilarity(SearchClientNew.java:78)</span><br></pre></td></tr></table></figure></p><p>原因是调用其他部门提供的Http接口连接不上.</p><p>有同事分享了一个相似的场景:<br>API调用Dubbo超时, 查看Dubbo日志发现线程池占满了. 查看线程信息后发现原因也是一个没有设置超时的HTTP请求阻塞.  </p><h3 id="3-2-查看CPU占用最高的线程-Linux"><a href="#3-2-查看CPU占用最高的线程-Linux" class="headerlink" title="3.2 查看CPU占用最高的线程(Linux)"></a>3.2 查看CPU占用最高的线程(Linux)</h3><p>输入<code>top</code>命令后按照CPU占用排序.</p><ul><li>Linux上是输入大写P.</li><li>Mac上是输入o, 再输入cpu后按enter键</li></ul><p><img src="http://7xokux.com1.z0.glb.clouddn.com/top.jpeg" alt=""></p><p>PID为1707. 继续查看CPU占用最大的线程, <code>top -H -p 1707</code>. 结果如下:</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/top-h.jpeg" alt=""></p><p>查看线程ID为1751对应的Java线程. 上文提到过, 这个线程对应的是结果中的NID. 但是<code>top</code>显示的是10进制, 而<code>stack</code>是16进制的. 1751的十六进制格式为0x6d7. 可以通过<code>jstack</code>查看对应的Java线程 <code>jstack 1707 | grep 0x6d7</code>即可看到是哪些Java代码造成的了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ReputMessageService&quot; #33 prio=5 os_prio=0 tid=0x00007ffb60743fa0 nid=0x6d7 waiting on condition [0x00007ffa6ddfa000]</span><br></pre></td></tr></table></figure><hr><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html" target="_blank" rel="noopener"><code>jstack</code> - Java SE Documetation</a></li><li><a href="https://gist.github.com/rednaxelafx/843622" target="_blank" rel="noopener">Find out the correspondence between the tid/nid of Java threads as shown from jstack/JMX, on HotSpot/Linux · R大 - GitHub</a></li><li><a href="https://dzone.com/articles/how-analyze-java-thread-dumps" target="_blank" rel="noopener">How to Analyze Java Thread Dumps - DZone Performance</a></li><li><a href="http://www.linuxidc.com/Linux/2015-06/118868.htm" target="_blank" rel="noopener">Linux上如何查看某个进程的线程_Linux公社</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Usage&quot;&gt;&lt;a href=&quot;#1-Usage&quot; class=&quot;headerlink&quot; title=&quot;1. Usage&quot;&gt;&lt;/a&gt;1. Usage&lt;/h2&gt;&lt;p&gt;&lt;code&gt;jstack&lt;/code&gt;是用来打印Stack trace的一个工具. 由JDK提供
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Java Tools" scheme="https://shibinfei.github.io/tags/Java-Tools/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrent - ThreadPoolExecutor特性&amp;实现</title>
    <link href="https://shibinfei.github.io/2017/11/24/Java%20Concurrent%20-%20ThreadPoolExecutor/"/>
    <id>https://shibinfei.github.io/2017/11/24/Java Concurrent - ThreadPoolExecutor/</id>
    <published>2017-11-24T10:48:54.000Z</published>
    <updated>2018-01-05T06:53:51.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么要使用线程池"><a href="#1-为什么要使用线程池" class="headerlink" title="1. 为什么要使用线程池?"></a>1. 为什么要使用线程池?</h2><p>这点在注释最开始说的很清楚:</p><blockquote><p> Thread pools address two different problems</p><ol><li>they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead,</li><li>and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks.</li></ol></blockquote><p>其中第一点也可以这样简单描述:</p><blockquote><p>Reusing threads that have already been created instead of creating new ones (an expensive process)<br><a href="https://stackoverflow.com/questions/230003/thread-vs-threadpool" target="_blank" rel="noopener">Answer from Thread vs ThreadPool on Stackoverflow</a></p></blockquote><h2 id="2-Worst-pool"><a href="#2-Worst-pool" class="headerlink" title="2. Worst pool"></a>2. Worst pool</h2><p>在一切开始之前, 先思考一个问题: 仅就”重用线程”这个首要目标来说, 该如何实现一个线程池? 比较明确的几点是:</p><pre><code>1. 一定创建固定数目的`Thread`, 任务由`Runnable`形式交给`Thread`执行.2. 根据线程的生命周期, 一个线程执行完成即进入 *Dead* 状态, 由此可知`Thread`不能停, 需要一直维持 *Running* 状态. 也就是说, 需要在其中执行一个”死循环”.</code></pre><p>于是最开始想到是这样的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class PoolThread &#123;</span><br><span class="line">private Thread thread;</span><br><span class="line">private Runnable task;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现需要在每个新任务到来时遍历<code>PoolThread</code>, 判断其工作状态从而决定是否将任务提交给他. 而且弹性比较差, 当所有线程空闲时, 新任务无法处理.<br>这里提前剧透, 看了<code>ThreadPoolExecutor</code>的实现, 是引入了一个生产-消费模型, <code>Runnable</code>直接进入队列(实际上有的并不是, 后面再提), 而Thread从队列中消费.<br>有了这些信息, 已经可以写出一个辣鸡队列了, 姑且称之为<code>WorstPool</code>. 代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.stream.IntStream;</span><br><span class="line">import com.google.common.collect.Queues;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shibinfei</span><br><span class="line"> */</span><br><span class="line">public class WorstPool &#123;</span><br><span class="line"></span><br><span class="line">    private BlockingQueue&lt;Runnable&gt; taskQueue = Queues.newArrayBlockingQueue(5);</span><br><span class="line"></span><br><span class="line">    public WorstPool(int poolSize) &#123;</span><br><span class="line">        IntStream.range(0, poolSize).forEach(x -&gt; createThreadAndRun());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void createThreadAndRun() &#123;</span><br><span class="line">        Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Runnable cmd;</span><br><span class="line">                try &#123;</span><br><span class="line">                    cmd = taskQueue.take(); // keep waiting</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    continue; // ...</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cmd.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Runnable cmd) &#123;</span><br><span class="line">        taskQueue.add(cmd); // 满了就抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    WorstPool pool = new WorstPool(2);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">        final int id = i;</span><br><span class="line">        pool.execute(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; DONE WITH &quot; + id);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以运行下看看结果~</p><h2 id="3-ThreadPoolExecutor"><a href="#3-ThreadPoolExecutor" class="headerlink" title="3. ThreadPoolExecutor"></a>3. ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>和<code>WorstPool</code>的主要模型是一致的. 了解后者之后, <code>ThreadPoolExecutor</code>就比较容易切入. 先尝试将<code>WorstPool</code>的成员对应到<code>ThreadPoolExecutor</code>.  之后再根据<code>ThreadPoolExecutor</code>的各种特性逐个了解.</p><h3 id="3-1-找相同-Worker-amp-BlockingQueue"><a href="#3-1-找相同-Worker-amp-BlockingQueue" class="headerlink" title="3.1 找相同 - Worker &amp; BlockingQueue"></a>3.1 找相同 - Worker &amp; BlockingQueue</h3><p>观察<code>ThreadPoolExecutor</code>的类成员, 可以很容易找到和<code>WorstPool</code>的对应.</p><pre><code>- `BlockingQueue&lt;Runnable&gt; workQueue` - `taskQueue` in `WorstPool`- 包含一个`Thread`成员的内部类`Worker` - `WorstPool`中没有做封装, 直接是一个`Thread`</code></pre><h4 id="3-1-1-Worker"><a href="#3-1-1-Worker" class="headerlink" title="3.1.1 Worker"></a>3.1.1 Worker</h4><p><code>Worker</code>成员较少, 可以先关注下面几个</p><pre><code>- `Thread thread`, 用来执行任务的线程- `Runnable task`,  在创建`Worker`会同时为其指定一个任务. 后续的任务将从队列中获取.</code></pre><p>在<code>ThreadPoolExecutor</code>中,  <code>Worker</code>不是在线程池初始化时创建的. 而是在提交任务时创建的, 即在客户端调用入口<code>execute(Runnable cmd)</code>方法中. <code>Worker</code>的创建以及执行任务流程大致如下:</p><p><img src="http://7xokux.com1.z0.glb.clouddn.com/threadpool-worker-creation-and-run-task.png" alt=""></p><p><code>addWorker</code>方法中, <code>Worker</code>实例会被加入到<code>HashSet&lt;Worker&gt; workers</code>. 用于线程池管理所有的<code>Worker</code>.</p><h4 id="Worker数量"><a href="#Worker数量" class="headerlink" title="Worker数量"></a>Worker数量</h4><p><code>Worker</code>数量可能不是固定的, 在<code>execute()</code>中, 判断是否需要新建<code>worker</code>主要看<code>corePoolSize</code>和<code>maximumPoolSize</code>. 注释讲的很清楚:</p><blockquote><p>A ThreadPoolExecutor will automatically adjust the pool size according to the bounds set by corePoolSize and maximumPoolSize.<br>When a new task is submitted in method  execute, and fewer than corePoolSize threads are running, a new thread is created to handle the request, even if other worker threads are idle.  If there are more than corePoolSize but less than maximumPoolSize threads running, a new thread will be created only if the queue is full.</p></blockquote><h4 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h4><p><code>Worker</code>本身继承了<code>AbstractQueuedSynchronizer</code>, 相关方法有<code>lock()</code>, <code>tryLock()</code>,<code>isLocked()</code>,<code>unlock()</code>.  等后续单独介绍<code>AbstractQueuedSynchronizer</code>, 暂时可以简单理解为, 内部维护了一个<code>ReentrantLock</code>实例. 具体使用后面会提到~</p><h4 id="Key-Words"><a href="#Key-Words" class="headerlink" title="Key Words"></a>Key Words</h4><p><em>Worker</em> <em>workQueue</em> <em>corePoolSize</em> <em>maximumPoolSize</em> <em> AbstractQueuedSynchronizer</em> <em>thread</em> <em>workers</em></p><h3 id="3-2-ctl"><a href="#3-2-ctl" class="headerlink" title="3.2 ctl"></a>3.2 ctl</h3><p><code>ThreadPoolExecutor</code>中有一个乍看起来有些令人困惑的成员 - <code>AtomicInteger ctl</code></p><blockquote><p>The main pool control state, ctl, is an atomic integer packing two conceptual fields: workerCount, runState.<br>实际上一些相关的位操作只是为了将两个变量封装到一个中: 高三位表示<code>runState</code>. 剩下的表示<code>workCount</code></p></blockquote><h4 id="WorkerCount"><a href="#WorkerCount" class="headerlink" title="WorkerCount"></a>WorkerCount</h4><p><code>workerCount</code>可以先简单地根据字面理解为<code>Worker</code>数量, 实际上却不大精准:</p><blockquote><p>The workerCount is the number of workers that have been permitted to start and not permitted to stop.<br>// TODO</p></blockquote><p><code>workerCountOf</code>, <code>ctlOf</code>等几个方法都是很简单的二进制操作, 下面详细说明.</p><h4 id="Bit操作详细说明"><a href="#Bit操作详细说明" class="headerlink" title="Bit操作详细说明"></a>Bit操作详细说明</h4><p>这里必须上源码了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int CAPACITY   = (1 &lt;&lt; (Integer.SIZE - 3)) - 1;</span><br><span class="line"></span><br><span class="line">// Packing and unpacking ctl</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure><p><code>CAPACITY</code>为<code>1</code>左移29位. 它的二进制表示为:<br>    0001 1111 1111 1111 1111 1111 1111 1111<br><code>~CAPACITY</code><br>    1110 0000 0000 0000 0000 0000 0000 0000</p><p>这样看就很好理解了. 两者一个是高位为1, 一个是低位为1, 这样在按位与操作时就会忽略其他为0的Bit, 达到封装两个值的效果. 可以看出<code>workerCount</code>的长度受限于29个bit, 最大为 (2 ^ 29) - 1. 而<code>runState</code>只有6种可能取值, 3位也够了.</p><h4 id="KeyWords"><a href="#KeyWords" class="headerlink" title="KeyWords"></a>KeyWords</h4><p><em>ctl</em> <em>workerCount</em> <em>runState</em></p><h3 id="3-3-生命周期"><a href="#3-3-生命周期" class="headerlink" title="3.3 生命周期"></a>3.3 生命周期</h3><p>上文提到 <code>ctl</code>包装的另一个值就是<code>runState</code>. 它的作用是用来表示整个线程池的生命周期状态, 取值有如下几种:</p><blockquote><p>The runState provides the main lifecyle control, taking on values:</p><pre><code>   - RUNNING:  Accept new tasks and process queued tasks- SHUTDOWN: Don&apos;t accept new tasks, but process queued tasks- STOP:     Don&apos;t accept new tasks, don&apos;t process queued tasks, and interrupt in-progress tasks- TIDYING:  All tasks have terminated, workerCount is zero, the thread transitioning to state      TIDYING will run the terminated() hook method- TERMINATED: terminated() has completed</code></pre></blockquote><p> 下面几个方法都是对<code>runState</code>简单的读写操作, 几乎可以根据名称判断用处</p><ul><li><code>runStateLessThan(int c, int s)</code></li><li><code>runStateAtLeast(int c, int s)</code></li><li><code>isTerminated()</code></li><li><code>isTerminating()</code></li><li><code>isShutdown()</code></li><li><code>isRunning(int c)    // 是否处于RUNNING状态</code></li><li><code>advanceRunState(int target)  // 将runState设置为目标值</code></li></ul><p>各种状态的转换说明如下:</p><blockquote><p>The runState monotonically increases over time, <strong>but need not hit each state</strong>. The transitions are:</p><pre><code>- RUNNING -&gt; SHUTDOWN: On invocation of shutdown(), perhaps implicitly in finalize()- (RUNNING or SHUTDOWN) -&gt; STOP: On invocation of shutdownNow()* SHUTDOWN -&gt; TIDYING:  When both queue and pool are empty* STOP -&gt; TIDYING:  When pool is empty    * TIDYING -&gt; TERMINATED: When the terminated() hook method has completed</code></pre></blockquote><p>可以看出来, 线程池初始化之后, 如果不调用<code>shutdown</code>, <code>shutdownNow</code>它是一直处于RUNNING状态的, 所以 <strong>生命周期的变化都始于这两个方法</strong>; 他们的作用都是试图停止线程池, 但是细节有所不同.</p><h4 id="showdown"><a href="#showdown" class="headerlink" title="showdown"></a>showdown</h4><p>此操作调用之前提交的任务(即包含队列中的任务)都会被执行完, 但是不再接受新任务.  另外此方法的注释中提到: (<code>shutdownNow</code>也是如此)</p><blockquote><p>This method does not wait for previously submitted tasks to complete execution.  Use awaitTermination awaitTermination<br>这句的意思是, <code>shutdown</code>并不会阻塞当前线程, 从而等待所有任务执行完. 如果需要的话, 使用<code>awaitTermination</code>. 下面的代码可以说明这一点:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 1, 1, TimeUnit.SECONDS, Queues.newArrayBlockingQueue(1));</span><br><span class="line">        pool.execute(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; in&quot;);</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; out&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; interrupted&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">        System.out.println(&quot;ShutDown OK&quot;);</span><br></pre></td></tr></table></figure><p>这里的”ShutDown OK”马上就打印了, 但是线程池中的任务还没有完成.</p><p><code>awaitTermination</code>的实现是通过一个<code>Condition termination</code>成员的<code>await</code>来实现的, 逻辑比较简单, 其中根据<code>runState</code>是否达到<code>TERMINATED</code>状态决定是否继续<code>await</code>.  通常有<code>await</code>就会有<code>signal</code>, 在后面会提到.</p><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p>此方法试图终止当前运行的任务, 并将队列中的任务全部移除. 由于试图终止的方式为<code>interrupt</code>, 所以实际上并不能保证一定成功.</p><h4 id="shutdown-amp-shutdownNow"><a href="#shutdown-amp-shutdownNow" class="headerlink" title="shutdown &amp; shutdownNow"></a>shutdown &amp; shutdownNow</h4><p>来看一下两个方法的主要内容:<br><img src="http://7xokux.com1.z0.glb.clouddn.com/ThreadPoolExecutor-shutdown.png" alt=""></p><ol><li><code>advanceRunState(state)</code><br>这里两个都有调用, 只不过目标值不同. 逻辑也仅仅为修改状态而已.  </li><li><code>interruptIdleWorkers</code> vs  <code>interruptWorkers</code>:<br>两者都是试图对进行中的worker thread进行<code>interrupt</code>. 不同的是,  前者会先调用<code>tryLock()</code>.  而在<code>runWorker</code>的循环中, 每次执行task会先调用<code>worker.lock()</code>, 结束才后<code>unlock</code>. 所以说非空闲的任务不会受到影响.</li><li><code>onShutdown</code><br>留给子类的一个钩子, 学习<code>ScheduledThreadPoolExecutor</code>再关注</li><li><code>drainQueue</code><br>将队列中的元素抽取到另一个List中, 并移除此元素.</li><li><code>tryTerminate</code><br>两者都有调用. 具体说明之前先回顾一下前面的<code>runState</code>转换:<ul><li>SHUTDOWN -&gt; TIDYING:  When both queue and pool are empty</li><li>STOP -&gt; TIDYING:  When pool is empty<br>这个转换过程即为<code>tryTerminate</code>做的事情.</li></ul></li></ol><p>查看<code>tryTerminate()</code>, 其中值得注意的是, 当为<code>SHUTDOWN</code>状态, 且队列不为空时, <code>tryTerminate</code>方法是直接<code>return</code>的.  而在<code>showdown</code>过程中, 很可能正好处于这种情况, 此时<code>shutdown</code>对<code>tryTerminate</code>的调用是无效的. 但是在后续, <code>tryTerminate</code>方法还会被调用一次, 即前面提到的<code>processWorkerExit</code></p><p>所以一个<code>ThreadPoolExecutor</code>的生命周期转换以及触发操作如下:<br>RUNNING (shutdown) -&gt; SHUTDOWN -&gt; TIDYING(tryTerminate) -&gt; TERMINATED<br>RUNNING (shutdownNow) -&gt; STOP -&gt; TIDYING(tryTerminate)  -&gt; TERMINATED</p><ol><li><code>RuntimePermission</code></li></ol><h3 id="3-4-Reject策略"><a href="#3-4-Reject策略" class="headerlink" title="3.4 Reject策略"></a>3.4 Reject策略</h3><p>回想<code>workerCount</code>策略:</p><ul><li>当<code>workerCount</code>小于<code>corePoolSize</code>, 有新任务会会创建<code>Worker</code>.</li><li>如果达到了<code>corePoolSize</code>, 会将任务放到队列中.</li><li>如果队列放不下了, 会尝试继续创建<code>Worker</code></li></ul><p>还有一点:</p><ul><li>如果<code>workerCount</code>即将超过<code>maximumPoolSize</code>, 那么将对对应的task执行Reject策略.</li></ul><p>这个策略的抽象即为<code>RejectedExecutionHandler#rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>.</p><p>四种预定义策略比较简单:</p><ol><li><code>AbortPolicy</code>(默认). 抛出一个异常(<code>RejectedExecutionException</code>)</li><li><code>CallerRunsPolicy</code>. 将提交的Task直接还给主线程同步执行.</li><li><code>DiscardPolicy</code>. 非常简单, 直接放弃治疗</li><li><code>DiscardOldestPolicy</code>.  抛弃队列头的任务, 重试执行.</li></ol><h3 id="3-5-KeepAliveTime-amp-allowCoreThreadTimeOut"><a href="#3-5-KeepAliveTime-amp-allowCoreThreadTimeOut" class="headerlink" title="3.5 KeepAliveTime &amp; allowCoreThreadTimeOut"></a>3.5 KeepAliveTime &amp; allowCoreThreadTimeOut</h3><p>通过两个参数<code>corePoolSize</code>, <code>maximumPoolSize</code>来控制Worker数量, 目标为使线程池更具有弹性, 保证一段时间内的任务量骤增也可以承受. 而下面则关于任务量从峰值降下来后, 如何减少线程池Worker数量, 从而减少资源占用.</p><p>默认情况下,  当Worker数量超过了corePoolSize之后, 且有Worker空闲了一段时间, 会有部分Worker被回收, 但是数量不会小于corePoolSize.  </p><p>举个栗子, 假设<code>corePoolSize == 5, maximumPoolSize == 10;</code>. 之前任务很多, 所以创建了10个Worker, 而此时任务被处理完. 对于超过<code>corePoolSize</code>数量的线程, 如果空闲时间超过了<code>keepAliveTime</code>, 则会被回收.</p><p>默认情况下, 即便回收也是会保证活跃线程数量 <code>&gt;= corePoolSize</code>的. 如果想打破这里逻辑, 可以设置<code>alloCoreThreadTimeOut</code>为<code>true</code>.  </p><p>对于超时时间的控制, 在<code>getTask()</code>中, 且仍然基于阻塞队列的特性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">// ...</span><br><span class="line">Runnable r = timed ?</span><br><span class="line">workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">         workQueue.take();</span><br><span class="line">timedOut = true;</span><br></pre></td></tr></table></figure><p>正常情况下, 使用<code>take()</code>会一直阻塞在这里, 而符合超时判断条件时, 则最多等<code>keepAliveTime</code>纳秒. 没有取到任务则<code>timeOut</code>则被置为<code>true</code>, 下次循环中会<code>return null</code>, 则对应的worker就结束了.(参考前文流程图) .</p><p>可以通过以下代码debug<code>getTask()</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 2, 1, TimeUnit.SECONDS, Queues.newArrayBlockingQueue(1));</span><br><span class="line">        pool.setKeepAliveTime(3, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>前三个任务, 两个直接交给了<code>Worker</code>, 一个从队列中消费, 所以<code>getTask()</code>的第一次调用可以忽略. 可以直接从第二次调用跟踪.</p><h2 id="4-整体概念回顾"><a href="#4-整体概念回顾" class="headerlink" title="4. 整体概念回顾"></a>4. 整体概念回顾</h2><p><img src="http://7xokux.com1.z0.glb.clouddn.com/ThreadPoolExecutor-Members.png" alt=""></p><h2 id="5-Best-Practice"><a href="#5-Best-Practice" class="headerlink" title="5. Best Practice"></a>5. Best Practice</h2><h3 id="5-1-线程池大小应该设置多少合适"><a href="#5-1-线程池大小应该设置多少合适" class="headerlink" title="5. 1 线程池大小应该设置多少合适"></a>5. 1 线程池大小应该设置多少合适</h3><h4 id="先给一个粗糙的结论"><a href="#先给一个粗糙的结论" class="headerlink" title="先给一个粗糙的结论"></a>先给一个粗糙的结论</h4><pre><code>取决于程序为CPU密集/IO密集. 如果接近完全为CPU密集的程序, 线程数应设置为CPU内核数量. IO密集则需要增加线程数.IO密集/CPU密集无法量化, 所以需要通过测试来决定.// TODO 如何进行测试</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-为什么要使用线程池&quot;&gt;&lt;a href=&quot;#1-为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么要使用线程池?&quot;&gt;&lt;/a&gt;1. 为什么要使用线程池?&lt;/h2&gt;&lt;p&gt;这点在注释最开始说的很清楚:&lt;/p&gt;
&lt;blockquote
      
    
    </summary>
    
      <category term="Java" scheme="https://shibinfei.github.io/categories/Java/"/>
    
    
      <category term="Concurrent" scheme="https://shibinfei.github.io/tags/Concurrent/"/>
    
  </entry>
  
</feed>
